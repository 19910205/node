node.meta
=========

Extending Nodes by different behaviors.


Concepts
--------

- Behavior related functionality is available and directly accessible on node.

- Behavior implementations do not have the behavioral enhanced node as base
  class, but act as an adapter on the node.

- Behaviors are bound to a node by decorator.

- The decorator implementation works with metaclasses.

- Node related functions, attributes and properties always rule, so we can
  overwrite anything on the decorated node, even behavior contract.

- If more than one behavior defines the same attribute or function, return
  first one, analog to the behavior of object inheritance.

- Behaviors can hook before and after attribute access of nodes. This is done
  with ``befor`` and ``after`` decorator, which expects name of attribute or
  function to get hooked.


Why using a decorator
---------------------

- It is not possible to custom hook import statements from user pov.

- Beside the fact they provide an easy hooking point for manipulating class 
  objects, they are elegant.


Behaviors and the behavior decorator
------------------------------------

Provide a behavior implementation.
::
    >>> from zope.interface import implements
    >>> from node.interfaces import IBehavior
    
    >>> class BaseBehavior(object):
    ...     implements(IBehavior)
    ... 
    ...     def __init__(self, context):
    ...         self.context = context
    ... 
    ...     def _print_hook_info(self, decorator, hooked, *args, **kw):
    ...         print '* ' + decorator + ' ``' + hooked + '`` of ' + \
    ...               str(self) + ' \n  on ' + str(self.context) + \
    ...               ' \n  with args ``' + str(args) + \
    ...               '`` \n  and kw ``' + str(kw) + '`` ---'
    
    >>> class SomeBehavior(BaseBehavior):
    ... 
    ...     def do(self):
    ...         return 'do something on ' + str(self.context)
    ... 
    ...     @property
    ...     def prop(self):
    ...         return 'prop'
    ... 
    ...     def _set_rw(self, val):
    ...         self._val = val
    ... 
    ...     def _get_rw(self):
    ...         return self._val
    ... 
    ...     rw = property(_get_rw, _set_rw)

Decorator expects ``IBehavior`` implementations.
::
    >>> from node.meta import behavior
    >>> from node.base import OrderedNode
    
    >>> @behavior
    ... class BehaviorNode(OrderedNode):
    ...     pass
    Traceback (most recent call last):
      ...
    TypeError: ``IBehavior`` not implemented by ``BehaviorNode``

    >>> @behavior(dict)
    ... class BehaviorNode(OrderedNode):
    ...     pass
    Traceback (most recent call last):
      ...
    TypeError: ``IBehavior`` not implemented by ``dict``

Decorating classes not providing ``INode`` with ``behavior`` will fail.
::
    >>> @behavior(SomeBehavior)
    ... class BehaviorNode(object):
    ...     pass
    Traceback (most recent call last):
      ...
    TypeError: ``INode`` not implemented by ``BehaviorNode``

Do the right thing.
::
    >>> @behavior(SomeBehavior)
    ... class BehaviorNode(OrderedNode):
    ...     pass

``BehavioralNode`` was wrapped.
::
    >>> BehaviorNode
    <class 'node.meta.NodeBehaviorWrapper'>

Behavior classes bound to node.
::
    >>> BehaviorNode.__behaviors_cls
    (<class 'SomeBehavior'>,)

Instanciate wrapped node.
::
    >>> node = BehaviorNode()
    >>> node
    <BehaviorNode object 'None' at ...>

No behavior instances yet. Are created on first attribute access.
::
    >>> node.__behaviors_ins
    Traceback (most recent call last):
      ...
    AttributeError: __behaviors_ins

    >>> node.do
    <bound method SomeBehavior.do of <SomeBehavior object at ...>>
    
    >>> node.__behaviors_ins
    {'SomeBehavior': <SomeBehavior object at ...>}

Use behavior functions and properties directly on decorated node.
::
    >>> node.do()
    "do something on <BehaviorNode object 'None' at ...>"
    
    >>> node.prop
    'prop'
    
    >>> node.rw = '123'
    >>> node.rw
    '123'

Define second behavior. It implements ``do`` as well.
::
    >>> class OtherBehavior(BaseBehavior):
    ... 
    ...     def perform(self):
    ...         return 'perform on ' + str(self.context)
    ... 
    ...     def do(self):
    ...         return 'do other on ' + str(self.context)

Both behaviors using node.
::
    >>> @behavior(SomeBehavior, OtherBehavior)
    ... class BehaviorNode(OrderedNode):
    ...     pass
    
    >>> node = BehaviorNode()
    >>> node.perform
    <bound method OtherBehavior.perform of <OtherBehavior object at ...>>
    
    >>> node.perform()
    "perform on <BehaviorNode object 'None' at ...>"

``do`` is used from ``SomeBehavior``, its first in behavior hierarchy.
::
    >>> node.do
    <bound method SomeBehavior.do of <SomeBehavior object at ...>>

    >>> node.do()
    "do something on <BehaviorNode object 'None' at ...>"

Reversed behavior order.
::
    >>> @behavior(OtherBehavior, SomeBehavior)
    ... class BehaviorNode(OrderedNode):
    ...     pass
    
    >>> node = BehaviorNode()
    >>> node.do
    <bound method OtherBehavior.do of <OtherBehavior object at ...>>
    
    >>> node.do()
    "do other on <BehaviorNode object 'None' at ...>"
    
    >>> node.perform()
    "perform on <BehaviorNode object 'None' at ...>"
    
    >>> node.rw = 'foo'
    >>> node.rw
    'foo'

Override ``do`` on decorated node.
::
    >>> @behavior(OtherBehavior, SomeBehavior)
    ... class BehaviorNode(OrderedNode):
    ... 
    ...     def do(self):
    ...         return 'do on node ' + str(self)
    
    >>> node = BehaviorNode()
    >>> node.do
    <bound method NodeBehaviorWrapper.do of <BehaviorNode object 'None' at ...>>
    
    >>> node.do()
    "do on node <BehaviorNode object 'None' at ...>"


Before and after hooks for behaviors
------------------------------------

Use function hooks in behaviors. Signature of hook function must be same as
of hooked function from node.

Import hook decorators.
::
    >>> from node.meta import before, after

Provide Behavior which hooks before ``node.get``.
::
    >>> class HookingBehavior(BaseBehavior):
    ... 
    ...     @before('get')
    ...     def before_get(self, key, default=None):
    ...         self._print_hook_info('before', 'get', key, default=default)

Decorate a node with hook defining behavior.
::
    >>> @behavior(HookingBehavior)
    ... class BehaviorNode(OrderedNode): pass

Hooks are stored in registries.
::
    >>> from node.meta import _BEFORE_HOOKS
    >>> from node.meta import _AFTER_HOOKS
    
    >>> _BEFORE_HOOKS
    {'get': [<function before_get at ...>]}
    
    >>> _AFTER_HOOKS
    {}

Instanciate and check wether hook gets called.
::
    >>> node = BehaviorNode('hooked')
    >>> node.get('foo', None)
    * before ``get`` of <HookingBehavior object at ...> 
      on <BehaviorNode object 'hooked' at ...> 
      with args ``('foo',)`` 
      and kw ``{'default': None}`` ---

Second behavior with after get hook.
::
    >>> class OtherHookingBehavior(BaseBehavior):
    ... 
    ...     @after('get')
    ...     def after_get(self, key, default=None):
    ...         self._print_hook_info('after', 'get', key, default=default)
    
    >>> @behavior(HookingBehavior, OtherHookingBehavior)
    ... class BehaviorNode(OrderedNode): pass
    
    >>> _BEFORE_HOOKS
    {'get': [<function before_get at ...>]}
    
    >>> _AFTER_HOOKS
    {'get': [<function after_get at ...>]}

Now before hook is called of ``HookingBehavior``, and after hook is called of
``OtherHookingBehavior``.
::
    >>> node = BehaviorNode('hooked')
    >>> node.get('foo', None)
    * before ``get`` of <HookingBehavior object at ...> 
      on <BehaviorNode object 'hooked' at ...> 
      with args ``('foo',)`` 
      and kw ``{'default': None}`` ---
    * after ``get`` of <OtherHookingBehavior object at ...> 
      on <BehaviorNode object 'hooked' at ...> 
      with args ``('foo',)`` 
      and kw ``{'default': None}`` ---

Two behaviors both defining before and after get hooks.
::
    >>> class HookBeforeAfterGet(BaseBehavior):
    ... 
    ...     @before('get')
    ...     def before_get(self, key, default=None):
    ...         self._print_hook_info('before', 'get', key, default=default)
    ... 
    ...     @after('get')
    ...     def after_get(self, key, default=None):
    ...         self._print_hook_info('after', 'get', key, default=default)
    
    >>> class OtherHookBeforeAfterGet(BaseBehavior):
    ... 
    ...     @before('get')
    ...     def before_get(self, key, default=None):
    ...         self._print_hook_info('before', 'get', key, default=default)
    ... 
    ...     @after('get')
    ...     def after_get(self, key, default=None):
    ...         self._print_hook_info('after', 'get', key, default=default)

If hook for function is defined in more than one behavior, they are called in
order of behavior registration.
::
    >>> @behavior(HookBeforeAfterGet, OtherHookBeforeAfterGet)
    ... class BehaviorNode(OrderedNode): pass
    
    >>> node = BehaviorNode('hooked')
    >>> node.get('foo', None)
    * before ``get`` of <HookBeforeAfterGet object at ...> 
      on <BehaviorNode object 'hooked' at ...> 
      with args ``('foo',)`` 
      and kw ``{'default': None}`` ---
    * before ``get`` of <OtherHookBeforeAfterGet object at ...> 
      on <BehaviorNode object 'hooked' at ...> 
      with args ``('foo',)`` 
      and kw ``{'default': None}`` ---
    * after ``get`` of <HookBeforeAfterGet object at ...> 
      on <BehaviorNode object 'hooked' at ...> 
      with args ``('foo',)`` 
      and kw ``{'default': None}`` ---
    * after ``get`` of <OtherHookBeforeAfterGet object at ...> 
      on <BehaviorNode object 'hooked' at ...> 
      with args ``('foo',)`` 
      and kw ``{'default': None}`` ---


Run Testers against wrapper
---------------------------

FullMappingTester.
::

    >>> @behavior(OtherBehavior, SomeBehavior)
    ... class BehaviorNode(OrderedNode):
    ... 
    ...     def do(self):
    ...         return 'do on node ' + str(self)
    
    >>> from node.testing import FullMappingTester
    >>> tester = FullMappingTester(BehaviorNode)
    >>> tester.run()
    >>> tester.combined
    ``__setitem__``: OK
    ``__getitem__``: OK
    ``get``: OK
    ``__iter__``: OK
    ``keys``: OK
    ``iterkeys``: OK
    ``values``: OK
    ``itervalues``: OK
    ``items``: OK
    ``iteritems``: OK
    ``__contains__``: OK
    ``has_key``: OK
    ``__len__``: OK
    ``update``: OK
    ``__delitem__``: OK
    ``copy``: OK
    ``setdefault``: OK
    ``pop``: OK
    ``popitem``: OK
    ``clear``: OK
