node.base
=========

Helper function for creating identically tree structures from different classes.
::

    >>> def create_tree(class_):
    ...     root = class_()
    ...     for i in range(3):
    ...         root['child-%i' % i] = class_()
    ...         for j in range(2):
    ...             root['child-%i' % i]['subchild-%i' % j] = class_()
    ...     return root


AbstractNode
------------
::

    >>> from node.base import AbstractNode
    >>> AbstractNode
    <class 'node.base.AbstractNode'>
    
    >>> AbstractNode.__bases__
    (<class 'node.base._NodeMixin'>, <class 'node.base._FullMappingMixin'>)
    
    >>> abstract = AbstractNode()
    >>> abstract
    <AbstractNode object 'None' at ...>

Storage related operations of AbstractNode raise ``NotImplementedError``.
::

    >>> abstract['foo']
    Traceback (most recent call last):
      ...
    NotImplementedError
    
    >>> del abstract['foo']
    Traceback (most recent call last):
      ...
    NotImplementedError
    
    >>> abstract['foo'] = 'bar'
    Traceback (most recent call last):
      ...
    NotImplementedError
    
    >>> [key for key in abstract]
    Traceback (most recent call last):
      ...
    NotImplementedError
    
    >>> abstract_copy = abstract.copy()
    Traceback (most recent call last):
      ...
    NotImplementedError
    
    >>> abstract.clear()
    Traceback (most recent call last):
      ...
    NotImplementedError
    
    >>> abstract.update((('foo', 'bar'),))
    Traceback (most recent call last):
      ...
    NotImplementedError
    
    >>> abstract.setdefault('foo', 'bar')
    Traceback (most recent call last):
      ...
    NotImplementedError
    
    >>> abstract.pop('foo')
    Traceback (most recent call last):
      ...
    NotImplementedError
    
    >>> abstract.popitem()
    Traceback (most recent call last):
      ...
    NotImplementedError
    
Subclass ``AbstractNode`` and provide needed functions.

Below we utilize ``odict.odict`` for most of the work. There exists node 
``OrderedNode``, which already uses odict, so for illustration we import odict
as somefullmapping.
::

    >>> from odict import odict as somefullmapping
    >>> class MyNode(AbstractNode, somefullmapping):
    ...     def __init__(self, name=None, parent=None):
    ...         # XXX: using ``super`` on dedicated base class? how?
    ...         somefullmapping.__init__(self)
    ...         AbstractNode.__init__(self, name, parent)
    ... 
    ...     __getitem__ = somefullmapping.__getitem__
    ... 
    ...     __delitem__ = somefullmapping.__delitem__
    ... 
    ...     def __setitem__(self, key, val):
    ...         val.__name__ = key
    ...         val.__parent__ = self
    ...         somefullmapping.__setitem__(self, key, val)
    ... 
    ...     __iter__ = somefullmapping.__iter__
    ... 
    ...     clear = somefullmapping.clear
    ... 
    ...     update = somefullmapping.update
    ... 
    ...     setdefault = somefullmapping.setdefault
    ... 
    ...     pop = somefullmapping.pop
    ... 
    ...     popitem = somefullmapping.popitem
    
    >>> mynode = MyNode()
    >>> mynode
    <MyNode object 'None' at ...>


BaseNode
--------
::

    >>> from node.base import BaseNode
    >>> BaseNode
    <class 'node.base.BaseNode'>
    
    >>> BaseNode.__bases__
    (<class 'node.base._NodeSpaceMixin'>, <type 'dict'>)
    
    >>> basenode = BaseNode()
    >>> basenode
    <BaseNode object 'None' at ...>


OrderedNode
-----------
::

    >>> from node.base import OrderedNode
    >>> OrderedNode
    <class 'node.base.OrderedNode'>
    
    >>> OrderedNode.__bases__
    (<class 'node.base._NodeSpaceMixin'>, <class 'odict.pyodict.odict'>)
    
    >>> orderednode = OrderedNode()
    >>> orderednode
    <OrderedNode object 'None' at ...>


IFullMapping contract
---------------------

``__setitem__``

Note if __name__ is set on added node, it gets overwritten by new key
::

    >>> mynode['foo'] = MyNode()
    >>> mynode['bar'] = MyNode(name='xxx')
    >>> basenode['foo'] = BaseNode()
    >>> basenode['bar'] = BaseNode(name='xxx')
    >>> orderednode['foo'] = OrderedNode()
    >>> orderednode['bar'] = OrderedNode(name='xxx')

``__getitem__``
::

    >>> mynode['foo']
    <MyNode object 'foo' at ...>
    
    >>> mynode['bar'].__name__
    'bar'
    
    >>> basenode['foo']
    <BaseNode object 'foo' at ...>
    
    >>> basenode['bar'].__name__
    'bar'
    
    >>> orderednode['foo']
    <OrderedNode object 'foo' at ...>
    
    >>> orderednode['bar'].__name__
    'bar'

``get``
::

    >>> mynode.get('bar')
    <MyNode object 'bar' at ...>
    
    >>> mynode.get('xxx', 'default')
    'default'
    
    >>> basenode.get('bar')
    <BaseNode object 'bar' at ...>
    
    >>> basenode.get('xxx', 'default')
    'default'
    
    >>> orderednode.get('bar')
    <OrderedNode object 'bar' at ...>
    
    >>> orderednode.get('xxx', 'default')
    'default'

``__iter__``
::

    >>> [key for key in mynode]
    ['foo', 'bar']
    
    >>> [key for key in basenode]
    ['foo', 'bar']
    
    >>> [key for key in orderednode]
    ['foo', 'bar']

``keys``
::

    >>> mynode.keys()
    ['foo', 'bar']
    
    >>> basenode.keys()
    ['foo', 'bar']
    
    >>> orderednode.keys()
    ['foo', 'bar']

``iterkeys``
::

    >>> [key for key in mynode.iterkeys()]
    ['foo', 'bar']
    
    >>> [key for key in basenode.iterkeys()]
    ['foo', 'bar']
    
    >>> [key for key in orderednode.iterkeys()]
    ['foo', 'bar']

``values``
::

    >>> mynode.values()
    [<MyNode object 'foo' at ...>, <MyNode object 'bar' at ...>]
    
    >>> basenode.values()
    [<BaseNode object 'foo' at ...>, <BaseNode object 'bar' at ...>]
    
    >>> orderednode.values()
    [<OrderedNode object 'foo' at ...>, <OrderedNode object 'bar' at ...>]

``itervalues``
::

    >>> [val for val in mynode.itervalues()]
    [<MyNode object 'foo' at ...>, <MyNode object 'bar' at ...>]
    
    >>> [val for val in basenode.itervalues()]
    [<BaseNode object 'foo' at ...>, <BaseNode object 'bar' at ...>]
    
    >>> [val for val in orderednode.itervalues()]
    [<OrderedNode object 'foo' at ...>, <OrderedNode object 'bar' at ...>]

``items``
::
    
    >>> mynode.items()
    [('foo', <MyNode object 'foo' at ...>), 
    ('bar', <MyNode object 'bar' at ...>)]
    
    >>> basenode.items()
    [('foo', <BaseNode object 'foo' at ...>), 
    ('bar', <BaseNode object 'bar' at ...>)]
    
    >>> orderednode.items()
    [('foo', <OrderedNode object 'foo' at ...>), 
    ('bar', <OrderedNode object 'bar' at ...>)]

``iteritems``
::

    >>> [item for item in mynode.iteritems()]
    [('foo', <MyNode object 'foo' at ...>), 
    ('bar', <MyNode object 'bar' at ...>)]
    
    >>> [item for item in basenode.iteritems()]
    [('foo', <BaseNode object 'foo' at ...>), 
    ('bar', <BaseNode object 'bar' at ...>)]
    
    >>> [item for item in orderednode.iteritems()]
    [('foo', <OrderedNode object 'foo' at ...>), 
    ('bar', <OrderedNode object 'bar' at ...>)]

``__contains__``
::

    >>> 'bar' in mynode
    True
    
    >>> 'bar' in basenode
    True
    
    >>> 'bar' in orderednode
    True

``has_key``
::

    >>> mynode.has_key('foo')
    True
    
    >>> basenode.has_key('foo')
    True
    
    >>> orderednode.has_key('foo')
    True

``__len__``
::

    >>> len(mynode)
    2
    
    >>> len(basenode)
    2
    
    >>> len(orderednode)
    2

``update``
::

    >>> mynode.update((('baz', MyNode()),))
    >>> mynode['baz']
    <MyNode object 'baz' at ...>
    
    >>> basenode.update((('baz', BaseNode()),))
    >>> basenode['baz']
    <BaseNode object 'baz' at ...>
    
    >>> orderednode.update((('baz', OrderedNode()),))
    >>> orderednode['baz']
    <OrderedNode object 'baz' at ...>

``__delitem__``
::

    >>> del mynode['bar']
    >>> mynode.keys()
    ['foo', 'baz']
    
    >>> del basenode['bar']
    >>> basenode.keys()
    ['baz', 'foo']
    
    >>> del orderednode['bar']
    >>> orderednode.keys()
    ['foo', 'baz']

``copy``
::

    >>> mycopied = mynode.copy()
    >>> mycopied
    <MyNode object 'None' at ...>
    
    >>> mycopied is mynode
    False
    
    >>> mycopied.items()
    [('foo', <MyNode object 'foo' at ...>), 
    ('baz', <MyNode object 'baz' at ...>)]
    
    >>> mycopied['foo'] is mynode['foo']
    True
    
    >>> basecopied = basenode.copy()
    >>> basecopied
    <BaseNode object 'None' at ...>
    
    >>> basecopied is basenode
    False
    
    >>> basecopied.items()
    [('foo', <BaseNode object 'foo' at ...>), 
    ('baz', <BaseNode object 'baz' at ...>)]
    
    >>> basecopied['foo'] is basenode['foo']
    True
    
    >>> orderedcopied = orderednode.copy()
    >>> orderedcopied
    <OrderedNode object 'None' at ...>
    
    >>> orderedcopied is orderednode
    False
    
    >>> orderedcopied.items()
    [('foo', <OrderedNode object 'foo' at ...>), 
    ('baz', <OrderedNode object 'baz' at ...>)]
    
    >>> orderedcopied['foo'] is orderednode['foo']
    True

``setdefault``
::

    >>> mynew = MyNode()
    >>> mynode.setdefault('foo', mynew) is mynew
    False
    
    >>> mynode.setdefault('bar', mynew) is mynew
    True
    
    >>> mynode.items()
    [('foo', <MyNode object 'foo' at ...>), 
    ('baz', <MyNode object 'baz' at ...>), 
    ('bar', <MyNode object 'bar' at ...>)]
    
    >>> basenew = BaseNode()
    >>> basenode.setdefault('foo', basenew) is basenew
    False
    
    >>> basenode.setdefault('bar', basenew) is basenew
    True
    
    >>> basenode.items()
    [('baz', <BaseNode object 'baz' at ...>), 
    ('foo', <BaseNode object 'foo' at ...>), 
    ('bar', <BaseNode object 'None' at ...>)]
    
    >>> orderednew = OrderedNode()
    >>> orderednode.setdefault('foo', orderednew) is orderednew
    False
    
    >>> orderednode.setdefault('bar', orderednew) is orderednew
    True

``pop``
::

    >>> mynode.pop('xxx')
    Traceback (most recent call last):
      ...
    KeyError: 'xxx'
    
    >>> mynode.pop('xxx', 'default')
    'default'
    
    >>> mynode.pop('foo')
    <MyNode object 'foo' at ...>
    
    >>> mynode.keys()
    ['baz', 'bar']
    
    >>> basenode.pop('xxx')
    Traceback (most recent call last):
      ...
    KeyError: 'xxx'
    
    >>> basenode.pop('xxx', 'default')
    'default'
    
    >>> basenode.pop('foo')
    <BaseNode object 'foo' at ...>
    
    >>> basenode.keys()
    ['baz', 'bar']
    
    >>> orderednode.pop('xxx')
    Traceback (most recent call last):
      ...
    KeyError: 'xxx'
    
    >>> orderednode.pop('xxx', 'default')
    'default'
    
    >>> orderednode.pop('foo')
    <OrderedNode object 'foo' at ...>
    
    >>> orderednode.keys()
    ['baz', 'bar']

``popitem`` and ``clear``
::

    >>> mynode.popitem()
    ('bar', <MyNode object 'bar' at ...>)
    
    >>> mynode.keys()
    ['baz']
    
    >>> mynode.clear()
    >>> mynode.keys()
    []
    
    >>> mynode.popitem()
    Traceback (most recent call last):
      ...
    KeyError: "'popitem(): ordered dictionary is empty'"
    
    >>> basenode.popitem()
    ('baz', <BaseNode object 'baz' at ...>)
    
    >>> basenode.keys()
    ['bar']
    
    >>> basenode.clear()
    >>> basenode.keys()
    []
    
    >>> basenode.popitem()
    Traceback (most recent call last):
      ...
    KeyError: 'popitem(): dictionary is empty'
    
    >>> orderednode.popitem()
    ('bar', <OrderedNode object 'bar' at ...>)
    
    >>> orderednode.keys()
    ['baz']
    
    >>> orderednode.clear()
    >>> orderednode.keys()
    []
    
    >>> orderednode.popitem()
    Traceback (most recent call last):
      ...
    KeyError: "'popitem(): ordered dictionary is empty'"


ILocation contract
------------------

``ILocations`` promises ``__name__`` and ``__parent__`` attributes. They are
used to define tree hierarchy.
::

    >>> mynode = create_tree(MyNode)
    >>> mynode
    <MyNode object 'None' at ...>
    
    >>> mynode.__name__
    >>> mynode.__parent__
    
    >>> mynode['child-1'].__name__
    'child-1'
    
    >>> mynode['child-1'].__parent__ is mynode
    True
    
    >>> mynode['child-1']['subchild-1'].__name__
    'subchild-1'
    
    >>> mynode['child-1']['subchild-1'].__parent__.__parent__ is mynode
    True
    
    >>> basenode = create_tree(BaseNode)
    >>> basenode
    <BaseNode object 'None' at ...>
    
    >>> basenode.__name__
    >>> basenode.__parent__
    
    >>> basenode['child-1'].__name__
    'child-1'
    
    >>> basenode['child-1'].__parent__ is basenode
    True
    
    >>> basenode['child-1']['subchild-1'].__name__
    'subchild-1'
    
    >>> basenode['child-1']['subchild-1'].__parent__.__parent__ is basenode
    True
    
    >>> orderednode = create_tree(OrderedNode)
    >>> orderednode
    <OrderedNode object 'None' at ...>

    >>> orderednode.__name__
    >>> orderednode.__parent__
    
    >>> orderednode['child-1'].__name__
    'child-1'
    
    >>> orderednode['child-1'].__parent__ is orderednode
    True
    
    >>> orderednode['child-1']['subchild-1'].__name__
    'subchild-1'
    
    >>> orderednode['child-1']['subchild-1'].__parent__.__parent__ is orderednode
    True


INode contract
--------------

``printtree``
::

    >>> mynode.printtree()
    <class 'MyNode'>: None
      <class 'MyNode'>: child-0
        <class 'MyNode'>: subchild-0
        <class 'MyNode'>: subchild-1
      <class 'MyNode'>: child-1
        <class 'MyNode'>: subchild-0
        <class 'MyNode'>: subchild-1
      <class 'MyNode'>: child-2
        <class 'MyNode'>: subchild-0
        <class 'MyNode'>: subchild-1
    
    >>> basenode.printtree()
    <class 'node.base.BaseNode'>: None
      <class 'node.base.BaseNode'>: child-...
        <class 'node.base.BaseNode'>: subchild-...
        <class 'node.base.BaseNode'>: subchild-...
      <class 'node.base.BaseNode'>: child-...
        <class 'node.base.BaseNode'>: subchild-...
        <class 'node.base.BaseNode'>: subchild-...
      <class 'node.base.BaseNode'>: child-...
        <class 'node.base.BaseNode'>: subchild-...
        <class 'node.base.BaseNode'>: subchild-...
    
    >>> orderednode.printtree()
    <class 'node.base.OrderedNode'>: None
      <class 'node.base.OrderedNode'>: child-0
        <class 'node.base.OrderedNode'>: subchild-0
        <class 'node.base.OrderedNode'>: subchild-1
      <class 'node.base.OrderedNode'>: child-1
        <class 'node.base.OrderedNode'>: subchild-0
        <class 'node.base.OrderedNode'>: subchild-1
      <class 'node.base.OrderedNode'>: child-2
        <class 'node.base.OrderedNode'>: subchild-0
        <class 'node.base.OrderedNode'>: subchild-1
    
    