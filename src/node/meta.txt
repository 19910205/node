node.meta
=========

Node class modification done in ``behaviors.__call__``.

Inherit from some base node implementation.
::
    >>> from node.base import OrderedNode
    
    >>> class BehaviorNode(OrderedNode):
    ...     pass

Provide dummy behaviors.
::

    >>> from node.meta import BaseBehavior
    >>> from node.meta import before
    >>> from node.meta import after
    
    >>> class BehaviorA(BaseBehavior):
    ...     expose_write_access_for = ['attr_a']
    ...     
    ...     attr_a = None
    ...     
    ...     @before('__getitem__')
    ...     def before_getitem(self, key):
    ...         self._debug('before', '__getitem__', key)
    
    >>> class BehaviorB(BaseBehavior):
    ...     
    ...     @before('__getitem__')
    ...     def before_getitem(self, key):
    ...         self._debug('before', '__getitem__', key)
    ...     
    ...     @after('values')
    ...     def after_values(self):
    ...         self._debug('after', 'values')
    
    >>> class BehaviorC(BaseBehavior):
    ...     expose_write_access_for = ['items']
    ...     items = None
    
__getattribute__ and __setattr__ are prohibited to get hooked.
::
    >>> class BehaviorD(BaseBehavior):
    ...     
    ...     @after('__setattr__')
    ...     def after_setattr(self):
    ...         pass
    Traceback (most recent call last):
      ...
    RuntimeError: Hooking forbidden for ``__setattr__`` and ``__getattribute__``

Try to find namespace conflicts. They could still appear if node sets an
attribute i.e. during __init__ time. 
::
    >>> from node.meta import _check_write_exposed_ns_conflict
    >>> behavior_classes = [BehaviorA, BehaviorB, BehaviorC]
    >>> _check_write_exposed_ns_conflict(BehaviorNode, behavior_classes)
    Traceback (most recent call last):
      ...
    RuntimeError: <class 'BehaviorC'> exposes "items", which is already 
    provided by <class 'BehaviorNode'>

Write behavior classes to node class.
::
    >>> behavior_classes = [BehaviorA, BehaviorB]
    >>> from node.meta import _CLS_ATTR
    >>> setattr(BehaviorNode, _CLS_ATTR, behavior_classes)
    >>> getattr(BehaviorNode, _CLS_ATTR)
    [<class 'BehaviorA'>, <class 'BehaviorB'>]

Test ``add__behavior_instances_property``.
::
    >>> from node.meta import _add__behavior_instances_property
    >>> _add__behavior_instances_property(BehaviorNode)
    >>> BehaviorNode._behavior_instances
    <property object at ...>

When _behavior_instances is accessed the first time, the behavior classes are
instanciated.
::
    >>> from node.meta import _INS_ATTR
    >>> node = BehaviorNode()
    >>> getattr(node, _INS_ATTR)
    Traceback (most recent call last):
      ...
    AttributeError: 'BehaviorNode' object has no attribute '__behaviors_ins'
    
    >>> node._behavior_instances
    odict([('BehaviorA', <BehaviorA object at ...>), 
    ('BehaviorB', <BehaviorB object at ...>)])
    
    >>> getattr(node, _INS_ATTR)
    odict([('BehaviorA', <BehaviorA object at ...>), 
    ('BehaviorB', <BehaviorB object at ...>)])

Back to class manipulation.

Test ``_hook_names``.
::
    >>> from node.meta import _hook_names
    >>> _hook_names(behavior_classes)
    ['values', '__getitem__']

Test ``collect_hooks_for``.
::
    >>> from node.meta import _collect_hooks_for
    >>> _collect_hooks_for(behavior_classes, 'nohooks')
    ([], [])
    
    >>> _collect_hooks_for(behavior_classes, 'values')
    ([], [(<class 'BehaviorB'>, <unbound method BehaviorB.after_values>)])
    
    >>> _collect_hooks_for(behavior_classes, '__getitem__')
    ([(<class 'BehaviorA'>, <unbound method BehaviorA.before_getitem>), 
    (<class 'BehaviorB'>, <unbound method BehaviorB.before_getitem>)], [])

Wrap functions and attributes for which hooks are provided by behaviors.
::
    >>> from node.meta import _hook_behaviored_functions
    >>> _hook_behaviored_functions(BehaviorNode, behavior_classes)
    
    >>> BehaviorNode.values
    <unbound method BehaviorNode.values>
    
    >>> BehaviorNode.values.wrapped
    <unbound method BehaviorNode.values>
    
    >>> node = BehaviorNode()
    >>> node['foo'] = BehaviorNode()
    >>> node.values()
    * after ``values`` of <BehaviorB object at ...> 
      on <BehaviorNode object 'None' at ...> 
      with args ``()`` 
      and kw ``{}`` ---
    [<BehaviorNode object 'foo' at ...>]
    
    >>> node['foo']
    * before ``__getitem__`` of <BehaviorA object at ...> 
      on <BehaviorNode object 'None' at ...> 
      with args ``('foo',)`` 
      and kw ``{}`` ---
    * before ``__getitem__`` of <BehaviorB object at ...> 
      on <BehaviorNode object 'None' at ...> 
      with args ``('foo',)`` 
      and kw ``{}`` ---
    <BehaviorNode object 'foo' at ...>

    >>> from node.meta import _alter_node___setattr__
    >>> #_alter_node___setattr__(BehaviorNode)

    >>> from node.meta import _alter_node___getattribute__
    >>> #_alter_node___getattribute__(BehaviorNode)


XXX: test unwrapped proxy

XXX: test super calls in behaviored nodes


###
# orgin below


Behaviors and the behavior decorator
------------------------------------

Provide a behavior implementation.
::
    >>> from zope.interface import implements
    >>> from node.interfaces import IBehavior
    >>> from node.meta import BaseBehavior
    
Behaviors are normally not instanciated by the user. This is done by the
behavioral extended Node
::
    
    >>> behavior = BaseBehavior(object())
    >>> behavior.context
    <object object at ...>

Overriding ``context`` on behavior is forbidden.

    >>> behavior.context = 'foo'
    Traceback (most recent call last):
      ...
    RuntimeError: Overriding ``context`` forbidden
    
    >>> class SomeBehavior(BaseBehavior):
    ...
    ...     _val = 'from behavior'
    ... 
    ...     def do(self):
    ...         return 'do something on ' + str(self.context)
    ... 
    ...     @property
    ...     def prop(self):
    ...         return 'prop'
    ... 
    ...     def _set_rw(self, val):
    ...         self._val = val
    ... 
    ...     def _get_rw(self):
    ...         return self._val
    ... 
    ...     rw = property(_get_rw, _set_rw)

Decorator expects ``IBehavior`` implementations.
::
    >>> from node.meta import behavior
    >>> from node.base import OrderedNode
    
XXX: this should probably be @behavior()

    >>> @behavior
    ... class SomeBehaviorNode(OrderedNode):
    ...     pass
    Traceback (most recent call last):
      ...
    TypeError: ``IBehavior`` not implemented by ``SomeBehaviorNode``

    >>> @behavior(dict)
    ... class SomeBehaviorNode(OrderedNode):
    ...     pass
    Traceback (most recent call last):
      ...
    TypeError: ``IBehavior`` not implemented by ``dict``

Decorating classes not providing ``INode`` with ``behavior`` will fail.
::
    >>> @behavior(SomeBehavior)
    ... class SomeBehaviorNode(object):
    ...     pass
    Traceback (most recent call last):
      ...
    TypeError: ``INode`` not implemented by ``SomeBehaviorNode``

Do the right thing.
::
    >>> @behavior(SomeBehavior)
    ... class SomeBehaviorNode(OrderedNode):
    ...     pass

Behavioral extended node was wrapped.
::
    >>> SomeBehaviorNode
    <class 'node.meta.NodeBehaviorWrapper'>

Behavior classes bound to node.
::
    >>> SomeBehaviorNode.__behaviors_cls
    (<class 'SomeBehavior'>,)

Instanciate wrapped node.
::
    >>> node = SomeBehaviorNode()
    >>> node
    <SomeBehaviorNode object 'None' at ...>

    >>> node.do
    <bound method SomeBehavior.do of <SomeBehavior object at ...>>
    
    >>> node._behavior_instances
    odict([('SomeBehavior', <SomeBehavior object at ...>)])

Use behavior functions and properties directly on decorated node.
::
    >>> node.do()
    "do something on <SomeBehaviorNode object 'None' at ...>"
    
    >>> node.prop
    'prop'

``rw`` was implemented as getter/setter propery. Since we have not exposed
this property for write access due to node yet, setting rw to node will write to
node, and return the one from node on next access.
::
    >>> node.rw
    'from behavior'

    >>> node.rw = '123'
    >>> node.rw
    '123'
    
    >>> node.__behaviors_ins['SomeBehavior'].rw
    'from behavior'
    
Now expose ``rw`` for writing. Note that a write exposed attribute must be
implemented as getter/setter property.
::
    >>> class BehaviorWriteExposed(SomeBehavior):
    ...     expose_write_access_for = ['rw']
    
    >>> @behavior(BehaviorWriteExposed)
    ... class WriteExposedBehaviorNode(OrderedNode):
    ...     pass
    
    >>> node = WriteExposedBehaviorNode()
    >>> node.rw = '123'
    >>> node.rw
    '123'
    
    >>> node._behavior_instances['BehaviorWriteExposed'].rw
    '123'

Define second behavior. It implements ``do`` as well.
::
    >>> class OtherBehavior(BaseBehavior):
    ... 
    ...     def perform(self):
    ...         return 'perform on ' + str(self.context)
    ... 
    ...     def do(self):
    ...         return 'do other on ' + str(self.context)

Both behaviors extended node.
::
    >>> @behavior(SomeBehavior, OtherBehavior)
    ... class MultiBehaviorNode(OrderedNode):
    ...     pass
    
    >>> node = MultiBehaviorNode()
    >>> node.perform
    <bound method OtherBehavior.perform of <OtherBehavior object at ...>>
    
    >>> node.perform()
    "perform on <MultiBehaviorNode object 'None' at ...>"

``do`` is used from ``SomeBehavior``, its first in behavior hierarchy.
::
    >>> node.do
    <bound method SomeBehavior.do of <SomeBehavior object at ...>>

    >>> node.do()
    "do something on <MultiBehaviorNode object 'None' at ...>"

Reversed behavior order.
::
    >>> @behavior(OtherBehavior, SomeBehavior)
    ... class ReversedMultiBehaviorNode(OrderedNode):
    ...     pass
    
    >>> node = ReversedMultiBehaviorNode()
    >>> node.do
    <bound method OtherBehavior.do of <OtherBehavior object at ...>>
    
    >>> node.do()
    "do other on <ReversedMultiBehaviorNode object 'None' at ...>"
    
    >>> node.perform()
    "perform on <ReversedMultiBehaviorNode object 'None' at ...>"
    
    >>> node.rw = 'foo'
    >>> node.rw
    'foo'

Override ``do`` on decorated node.
::
    >>> @behavior(OtherBehavior, SomeBehavior)
    ... class OverridesBehaviorNode(OrderedNode):
    ... 
    ...     def do(self):
    ...         return 'do on node ' + str(self)
    
    >>> node = OverridesBehaviorNode()
    >>> node.do
    <bound method NodeBehaviorWrapper.do of 
    <OverridesBehaviorNode object 'None' at ...>>
    
    >>> node.do()
    "do on node <OverridesBehaviorNode object 'None' at ...>"


Before and after hooks for behaviors
------------------------------------

Use function hooks in behaviors. Signature of hook function must be same as
of hooked function from node.

Import hook decorators.
::
    >>> from node.meta import before, after

Provide Behavior which hooks before ``node.get``.
::
    >>> class HookBeforeGet(BaseBehavior):
    ... 
    ...     @before('get')
    ...     def before_get(self, key, default=None):
    ...         self._debug('before', 'get', key, default=default)

Decorate a node with hook defining behavior.
::
    >>> @behavior(HookBeforeGet)
    ... class BeforeGetHookedNode(OrderedNode): pass

Hooks are stored in registries.
::

    >>> from node.meta import _BEFORE_HOOKS
    >>> from node.meta import _AFTER_HOOKS
    
    >>> _BEFORE_HOOKS
    {...}
    
    >>> _AFTER_HOOKS
    {...}

Instanciate and check wether hook gets called.
::
    >>> node = BeforeGetHookedNode('hooked')
    >>> node.get('foo', None)
    * before ``get`` of <HookBeforeGet object at ...> 
      on <BeforeGetHookedNode object 'hooked' at ...> 
      with args ``('foo',)`` 
      and kw ``{'default': None}`` ---

    >>> node.get('bar', None)
    * before ``get`` of <HookBeforeGet object at ...> 
      on <BeforeGetHookedNode object 'hooked' at ...> 
      with args ``('bar',)`` 
      and kw ``{'default': None}`` ---

Second behavior with after get hook.
::
    >>> class HookAfterGet(BaseBehavior):
    ... 
    ...     @after('get')
    ...     def after_get(self, key, default=None):
    ...         self._debug('after', 'get', key, default=default)
    
    >>> @behavior(HookBeforeGet, HookAfterGet)
    ... class BeforeAfterGetHookedNode(OrderedNode): pass

Now before hook is called of ``HookBeforeGet``, and after hook is called of
``HookAfterGet``.
::
    >>> node = BeforeAfterGetHookedNode('hooked')
    >>> node.get('foo', None)
    * before ``get`` of <HookBeforeGet object at ...> 
      on <BeforeAfterGetHookedNode object 'hooked' at ...> 
      with args ``('foo',)`` 
      and kw ``{'default': None}`` ---
    * after ``get`` of <HookAfterGet object at ...> 
      on <BeforeAfterGetHookedNode object 'hooked' at ...> 
      with args ``('foo',)`` 
      and kw ``{'default': None}`` ---

Two behaviors both defining before and after get hooks.
::
    >>> class HookBeforeAfterGet(BaseBehavior):
    ... 
    ...     @before('get')
    ...     def before_get(self, key, default=None):
    ...         self._debug('before', 'get', key, default=default)
    ... 
    ...     @after('get')
    ...     def after_get(self, key, default=None):
    ...         self._debug('after', 'get', key, default=default)
    
    >>> class OtherHookBeforeAfterGet(BaseBehavior):
    ... 
    ...     @before('get')
    ...     def before_get(self, key, default=None):
    ...         self._debug('before', 'get', key, default=default)
    ... 
    ...     @after('get')
    ...     def after_get(self, key, default=None):
    ...         self._debug('after', 'get', key, default=default)

If hook for function is defined in more than one behavior, they are called in
order of behavior registration.
::
    >>> @behavior(HookBeforeAfterGet, OtherHookBeforeAfterGet)
    ... class MultiBeforeAfterGetHookedNode(OrderedNode): pass
    
    >>> node = MultiBeforeAfterGetHookedNode('hooked')
    >>> node.get('foo', None)
    * before ``get`` of <HookBeforeAfterGet object at ...> 
      on <MultiBeforeAfterGetHookedNode object 'hooked' at ...> 
      with args ``('foo',)`` 
      and kw ``{'default': None}`` ---
    * before ``get`` of <OtherHookBeforeAfterGet object at ...> 
      on <MultiBeforeAfterGetHookedNode object 'hooked' at ...> 
      with args ``('foo',)`` 
      and kw ``{'default': None}`` ---
    * after ``get`` of <HookBeforeAfterGet object at ...> 
      on <MultiBeforeAfterGetHookedNode object 'hooked' at ...> 
      with args ``('foo',)`` 
      and kw ``{'default': None}`` ---
    * after ``get`` of <OtherHookBeforeAfterGet object at ...> 
      on <MultiBeforeAfterGetHookedNode object 'hooked' at ...> 
      with args ``('foo',)`` 
      and kw ``{'default': None}`` ---

Hook data structure related private functions.
::
    >>> class HookBeforeAfterGetItem(BaseBehavior):
    ... 
    ...     @before('__getitem__')
    ...     def before_getitem(self, key):
    ...         self._debug('before', '__getitem__', key)
    ... 
    ...     @after('__getitem__')
    ...     def after_getitem(self, key):
    ...         self._debug('after', '__getitem__', key)
    
    >>> class HookBeforeAfterSetItem(BaseBehavior):
    ... 
    ...     @before('__setitem__')
    ...     def before_setitem(self, key, value):
    ...         self._debug('before', '__setitem__', key, value)
    ... 
    ...     @after('__setitem__')
    ...     def after_setitem(self, key, value):
    ...         self._debug('after', '__setitem__', key, value)
    
    >>> @behavior(HookBeforeAfterGetItem, HookBeforeAfterSetItem)
    ... class BeforeAfterGetItemHookedNode(OrderedNode): pass
    
    >>> node = BeforeAfterGetItemHookedNode('hooked')
    >>> node['foo'] = BeforeAfterGetItemHookedNode()
    * before ``__setitem__`` of <HookBeforeAfterSetItem object at ...> 
      on <BeforeAfterGetItemHookedNode object 'hooked' at ...> 
      with args ``('foo', <BeforeAfterGetItemHookedNode object 'None' at ...>)`` 
      and kw ``{}`` ---
    * after ``__setitem__`` of <HookBeforeAfterSetItem object at ...> 
      on <BeforeAfterGetItemHookedNode object 'hooked' at ...> 
      with args ``('foo', <BeforeAfterGetItemHookedNode object 'foo' at ...>)`` 
      and kw ``{}`` ---
    
    >>> node['bar'] = BeforeAfterGetItemHookedNode()
    * before ``__setitem__`` of <HookBeforeAfterSetItem object at ...> 
      on <BeforeAfterGetItemHookedNode object 'hooked' at ...> 
      with args ``('bar', <BeforeAfterGetItemHookedNode object 'None' at ...>)`` 
      and kw ``{}`` ---
    * after ``__setitem__`` of <HookBeforeAfterSetItem object at ...> 
      on <BeforeAfterGetItemHookedNode object 'hooked' at ...> 
      with args ``('bar', <BeforeAfterGetItemHookedNode object 'bar' at ...>)`` 
      and kw ``{}`` ---
    
    >>> node['foo']
    * before ``__getitem__`` of <HookBeforeAfterGetItem object at ...> 
      on <BeforeAfterGetItemHookedNode object 'hooked' at ...> 
      with args ``('foo',)`` 
      and kw ``{}`` ---
    * after ``__getitem__`` of <HookBeforeAfterGetItem object at ...> 
      on <BeforeAfterGetItemHookedNode object 'hooked' at ...> 
      with args ``('foo',)`` 
      and kw ``{}`` ---
    <BeforeAfterGetItemHookedNode object 'foo' at ...>
    
    >>> node['foo']['bar'] = OrderedNode()
    * before ``__getitem__`` of <HookBeforeAfterGetItem object at ...> 
      on <BeforeAfterGetItemHookedNode object 'hooked' at ...> 
      with args ``('foo',)`` 
      and kw ``{}`` ---
    * after ``__getitem__`` of <HookBeforeAfterGetItem object at ...> 
      on <BeforeAfterGetItemHookedNode object 'hooked' at ...> 
      with args ``('foo',)`` 
      and kw ``{}`` ---
    * before ``__setitem__`` of <HookBeforeAfterSetItem object at ...> 
      on <BeforeAfterGetItemHookedNode object 'foo' at ...> 
      with args ``('bar', <OrderedNode object 'None' at ...>)`` 
      and kw ``{}`` ---
    * after ``__setitem__`` of <HookBeforeAfterSetItem object at ...> 
      on <BeforeAfterGetItemHookedNode object 'foo' at ...> 
      with args ``('bar', <OrderedNode object 'bar' at ...>)`` 
      and kw ``{}`` ---

Remember. The context object on behavior implementation is the behavior 
enhanced node. Test if context access on behavior does not trigger before and 
after handler from within.

Hooked via ``__getattribute__``.
::
    >>> class HookGetAccessFromWithin(BaseBehavior):
    ... 
    ...     @before('get')
    ...     def before_get(self, key, default=None):
    ...         print 'call ``get`` on ' + str(self.context.get(key)) + \
    ...         ' within behavior hook'
    ...         self._debug('before', 'get', key, default=default)
    
    >>> @behavior(HookGetAccessFromWithin)
    ... class AccessedGetFromWithinNode(OrderedNode): pass
    
    >>> node = AccessedGetFromWithinNode('hooked')
    >>> node['foo'] = OrderedNode()
    >>> node.get('foo')
    call ``get`` on <OrderedNode object 'foo' at ...> within behavior hook
    * before ``get`` of <HookGetAccessFromWithin object at ...> 
      on <AccessedGetFromWithinNode object 'hooked' at ...> 
      with args ``('foo',)`` 
      and kw ``{'default': None}`` ---
    <OrderedNode object 'foo' at ...>

Hooked via metaclass constructor.
::
    >>> class HookGetItemAccessFromWithin(BaseBehavior):
    ... 
    ...     @before('__getitem__')
    ...     def before_getitem(self, key):
    ...         print 'call ``__getitem__`` on ' + str(self.context[key]) + \
    ...         ' within behavior hook'
    ...         self._debug('before', '__getitem__', key)
    
    >>> @behavior(HookGetItemAccessFromWithin)
    ... class AccessedGetItemFromWithinNode(OrderedNode): pass
    
    >>> node = AccessedGetItemFromWithinNode('hooked')
    >>> node['foo'] = OrderedNode()
    >>> node['foo']
    call ``__getitem__`` on <OrderedNode object 'foo' at ...> within behavior hook
    * before ``__getitem__`` of <HookGetItemAccessFromWithin object at ...> 
      on <AccessedGetItemFromWithinNode object 'hooked' at ...> 
      with args ``('foo',)`` 
      and kw ``{}`` ---
    <OrderedNode object 'foo' at ...>

Test hook on function derived and overwritten function.
::
    >>> class HookBeforValues(BaseBehavior):
    ...
    ...     @before('values')
    ...     def before_values(self):
    ...         self._debug('before', 'values')
    
    >>> @behavior(HookBeforValues)
    ... class BeforValuesDerivedHookedNode(OrderedNode): pass
    
    >>> node = BeforValuesDerivedHookedNode('hooked')
    >>> node.values()
    * before ``values`` of <HookBeforValues object at ...> 
      on <BeforValuesDerivedHookedNode object 'hooked' at ...> 
      with args ``()`` 
      and kw ``{}`` ---
    []
    
    >>> @behavior(HookBeforValues)
    ... class BeforValuesOverrideHookedNode(OrderedNode):
    ... 
    ...     def values(self):
    ...         return OrderedNode.values(self)
    
    >>> node = BeforValuesOverrideHookedNode('hooked')
    >>> node['foo'] = OrderedNode()
    >>> node.values()
    * before ``values`` of <HookBeforValues object at ...> 
      on <BeforValuesOverrideHookedNode object 'hooked' at ...> 
      with args ``()`` 
      and kw ``{}`` ---
    [<OrderedNode object 'foo' at ...>]

Test hook on property. Fails! Hooks can only be set on functions.
::
    >>> class HookBeforSomeProp(BaseBehavior):
    ... 
    ...     @before('someprop')
    ...     def before_seomprop(self, name, value=None):
    ...         pass
    
    >>> @behavior(HookBeforSomeProp)
    ... class BeforSomepropHookedNode(OrderedNode):
    ... 
    ...     @property
    ...     def someprop(self):
    ...         return 'foo'
    
    >>> node = BeforSomepropHookedNode('hooked')
    >>> node.someprop
    Traceback (most recent call last):
      ...
    AttributeError: someprop

Hooking to behavior proxied function does not work either.
::
    >>> class HookBeforeProxiedDoFunc(BaseBehavior):
    ... 
    ...     def do(self):
    ...         print 'behavior do called'
    ... 
    ...     @before('do')
    ...     def before_do(self):
    ...         self._debug('before', 'do')
    
    >>> @behavior(HookBeforeProxiedDoFunc)
    ... class BeforeProxiedDoFuncHookedNode(OrderedNode): pass 
    
    >>> node = BeforeProxiedDoFuncHookedNode('hooked')
    >>> node.do()
    behavior do called

When providing ``do`` on node as well, the hook will be called. Always check
used behavior interfaces for it's contracts and avoid such magic.
::
    >>> @behavior(HookBeforeProxiedDoFunc)
    ... class BeforeInheritedDoFuncHookedNode(OrderedNode):
    ... 
    ...     def do(self):
    ...         print 'node do called'
    
    >>> node = BeforeInheritedDoFuncHookedNode('hooked')
    >>> node.do()
    * before ``do`` of <HookBeforeProxiedDoFunc object at ...> 
      on <BeforeInheritedDoFuncHookedNode object 'hooked' at ...> 
      with args ``()`` 
      and kw ``{}`` ---
    node do called

Inheriting from a behavior and override hook function.

Does not work without the ``before`` decorator.
::
    >>> class HookOverridingHookIgnored(HookBeforValues):
    ... 
    ...     def before_values(self):
    ...         print 'derived before values'
    
    >>> @behavior(HookOverridingHookIgnored)
    ... class BeforeHookOverridingHookedIgnoredNode(OrderedNode): pass
    
    >>> node = BeforeHookOverridingHookedIgnoredNode('hooked')
    >>> node.values()
    []
    
With decorator.
::
    
    >>> class HookOverridingHook(HookBeforValues):
    ... 
    ...     @before('values')
    ...     def before_values(self):
    ...         print 'derived before values'
    
    >>> @behavior(HookOverridingHook)
    ... class BeforeHookOverridingHookedNode(OrderedNode): pass
    
    >>> node = BeforeHookOverridingHookedNode('hooked')
    >>> node.values()
    derived before values
    []

Check ``noderepr``.
::
    >>> node.noderepr
    "<class 'BeforeHookOverridingHookedNode'>: hooked"


Run Testers against wrapper
---------------------------

FullMappingTester.
::
    >>> @behavior(OtherBehavior, SomeBehavior)
    ... class BehaviorNode(OrderedNode):
    ... 
    ...     def do(self):
    ...         return 'do on node ' + str(self)
    
    >>> from node.testing import FullMappingTester
    >>> tester = FullMappingTester(BehaviorNode)
    >>> tester.run()
    >>> tester.combined
    ``__setitem__``: OK
    ``__getitem__``: OK
    ``get``: OK
    ``__iter__``: OK
    ``keys``: OK
    ``iterkeys``: OK
    ``values``: OK
    ``itervalues``: OK
    ``items``: OK
    ``iteritems``: OK
    ``__contains__``: OK
    ``has_key``: OK
    ``__len__``: OK
    ``update``: OK
    ``__delitem__``: OK
    ``copy``: OK
    ``setdefault``: OK
    ``pop``: OK
    ``popitem``: OK
    ``clear``: OK
