node.meta
=========

Extending Nodes by different behaviors.


Concepts
--------

- Behavior related functionality is available and directly accessible on node.

- Behavior implementations do not have the behavioral enhanced node as base
  class, but act as an adapter on the node.

- Behaviors are bound to a node by decorator.

- The decorator implementation works with metaclasses.

- Node related functions, attributes and properties always rule, so we can
  overwrite anything on the decorated node, even behavior contract.

- If more than one behavior defines the same attribute or function, return
  first one, analog to the behavior of object inheritance.

- Behaviors can hook before and after attribute access of nodes. This is done
  with ``befor`` and ``after`` decorator, which expects name of attribute or
  function to get hooked.


Why using a decorator
---------------------

- It is not possible to custom hook import statements from user pov.

- Beside the fact they provide an easy hooking point for manipulating class 
  objects, they are elegant.


Behaviors and the behavior decorator
------------------------------------

Provide a behavior implementation.
::
    >>> from zope.interface import implements
    >>> from node.interfaces import IBehavior
    >>> from node.meta import BaseBehavior
    
Behaviors are normally not instanciated by the user. This is done by the
behavioral extended Node
::
    
    >>> behavior = BaseBehavior(object())
    >>> behavior.context
    <object object at ...>

Overriding ``context`` on behavior is forbidden.

    >>> behavior.context = 'foo'
    Traceback (most recent call last):
      ...
    RuntimeError: Overriding ``context`` forbidden
    
    >>> class SomeBehavior(BaseBehavior):
    ... 
    ...     def do(self):
    ...         return 'do something on ' + str(self.context)
    ... 
    ...     @property
    ...     def prop(self):
    ...         return 'prop'
    ... 
    ...     def _set_rw(self, val):
    ...         self._val = val
    ... 
    ...     def _get_rw(self):
    ...         return self._val
    ... 
    ...     rw = property(_get_rw, _set_rw)

Decorator expects ``IBehavior`` implementations.
::
    >>> from node.meta import behavior
    >>> from node.base import OrderedNode
    
    >>> @behavior
    ... class BehaviorNode(OrderedNode):
    ...     pass
    Traceback (most recent call last):
      ...
    TypeError: ``IBehavior`` not implemented by ``BehaviorNode``

    >>> @behavior(dict)
    ... class BehaviorNode(OrderedNode):
    ...     pass
    Traceback (most recent call last):
      ...
    TypeError: ``IBehavior`` not implemented by ``dict``

Decorating classes not providing ``INode`` with ``behavior`` will fail.
::
    >>> @behavior(SomeBehavior)
    ... class BehaviorNode(object):
    ...     pass
    Traceback (most recent call last):
      ...
    TypeError: ``INode`` not implemented by ``BehaviorNode``

Do the right thing.
::
    >>> @behavior(SomeBehavior)
    ... class BehaviorNode(OrderedNode):
    ...     pass

``BehavioralNode`` was wrapped.
::
    >>> BehaviorNode
    <class 'node.meta.NodeBehaviorWrapper'>

Behavior classes bound to node.
::
    >>> BehaviorNode.__behaviors_cls
    (<class 'SomeBehavior'>,)

Instanciate wrapped node.
::
    >>> node = BehaviorNode()
    >>> node
    <BehaviorNode object 'None' at ...>

No behavior instances yet. Are created on first attribute access.
::
    >>> #node.__behaviors_ins
    Traceback (most recent call last):
      ...
    AttributeError: __behaviors_ins

    >>> node.do
    <bound method SomeBehavior.do of <SomeBehavior object at ...>>
    
    >>> node.__behaviors_ins
    {'SomeBehavior': <SomeBehavior object at ...>}

Use behavior functions and properties directly on decorated node.
::
    >>> node.do()
    "do something on <BehaviorNode object 'None' at ...>"
    
    >>> node.prop
    'prop'
    
    >>> node.rw = '123'
    >>> node.rw
    '123'

Define second behavior. It implements ``do`` as well.
::
    >>> class OtherBehavior(BaseBehavior):
    ... 
    ...     def perform(self):
    ...         return 'perform on ' + str(self.context)
    ... 
    ...     def do(self):
    ...         return 'do other on ' + str(self.context)

Both behaviors using node.
::
    >>> @behavior(SomeBehavior, OtherBehavior)
    ... class BehaviorNode(OrderedNode):
    ...     pass
    
    >>> node = BehaviorNode()
    >>> node.perform
    <bound method OtherBehavior.perform of <OtherBehavior object at ...>>
    
    >>> node.perform()
    "perform on <BehaviorNode object 'None' at ...>"

``do`` is used from ``SomeBehavior``, its first in behavior hierarchy.
::
    >>> node.do
    <bound method SomeBehavior.do of <SomeBehavior object at ...>>

    >>> node.do()
    "do something on <BehaviorNode object 'None' at ...>"

Reversed behavior order.
::
    >>> @behavior(OtherBehavior, SomeBehavior)
    ... class BehaviorNode(OrderedNode):
    ...     pass
    
    >>> node = BehaviorNode()
    >>> node.do
    <bound method OtherBehavior.do of <OtherBehavior object at ...>>
    
    >>> node.do()
    "do other on <BehaviorNode object 'None' at ...>"
    
    >>> node.perform()
    "perform on <BehaviorNode object 'None' at ...>"
    
    >>> node.rw = 'foo'
    >>> node.rw
    'foo'

Override ``do`` on decorated node.
::
    >>> @behavior(OtherBehavior, SomeBehavior)
    ... class BehaviorNode(OrderedNode):
    ... 
    ...     def do(self):
    ...         return 'do on node ' + str(self)
    
    >>> node = BehaviorNode()
    >>> node.do
    <bound method NodeBehaviorWrapper.do of <BehaviorNode object 'None' at ...>>
    
    >>> node.do()
    "do on node <BehaviorNode object 'None' at ...>"


Before and after hooks for behaviors
------------------------------------

Use function hooks in behaviors. Signature of hook function must be same as
of hooked function from node.

Import hook decorators.
::
    >>> from node.meta import before, after

Provide Behavior which hooks before ``node.get``.
::
    >>> class HookingBehavior(BaseBehavior):
    ... 
    ...     @before('get')
    ...     def before_get(self, key, default=None):
    ...         self._debug('before', 'get', key, default=default)

Decorate a node with hook defining behavior.
::
    >>> @behavior(HookingBehavior)
    ... class BehaviorNode(OrderedNode): pass

Hooks are stored in registries.
::
    >>> from node.meta import _BEFORE_HOOKS
    >>> from node.meta import _AFTER_HOOKS
    
    >>> _BEFORE_HOOKS
    {'get': [<function before_get at ...>]}
    
    >>> _AFTER_HOOKS
    {}

Instanciate and check wether hook gets called.
::
    >>> node = BehaviorNode('hooked')
    >>> node.get('foo', None)
    * before ``get`` of <HookingBehavior object at ...> 
      on <BehaviorNode object 'hooked' at ...> 
      with args ``('foo',)`` 
      and kw ``{'default': None}`` ---

Second behavior with after get hook.
::
    >>> class OtherHookingBehavior(BaseBehavior):
    ... 
    ...     @after('get')
    ...     def after_get(self, key, default=None):
    ...         self._debug('after', 'get', key, default=default)
    
    >>> @behavior(HookingBehavior, OtherHookingBehavior)
    ... class BehaviorNode(OrderedNode): pass
    
    >>> _BEFORE_HOOKS
    {'get': [<function before_get at ...>]}
    
    >>> _AFTER_HOOKS
    {'get': [<function after_get at ...>]}

Now before hook is called of ``HookingBehavior``, and after hook is called of
``OtherHookingBehavior``.
::
    >>> node = BehaviorNode('hooked')
    >>> node.get('foo', None)
    * before ``get`` of <HookingBehavior object at ...> 
      on <BehaviorNode object 'hooked' at ...> 
      with args ``('foo',)`` 
      and kw ``{'default': None}`` ---
    * after ``get`` of <OtherHookingBehavior object at ...> 
      on <BehaviorNode object 'hooked' at ...> 
      with args ``('foo',)`` 
      and kw ``{'default': None}`` ---

Two behaviors both defining before and after get hooks.
::
    >>> class HookBeforeAfterGet(BaseBehavior):
    ... 
    ...     @before('get')
    ...     def before_get(self, key, default=None):
    ...         self._debug('before', 'get', key, default=default)
    ... 
    ...     @after('get')
    ...     def after_get(self, key, default=None):
    ...         self._debug('after', 'get', key, default=default)
    
    >>> class OtherHookBeforeAfterGet(BaseBehavior):
    ... 
    ...     @before('get')
    ...     def before_get(self, key, default=None):
    ...         self._debug('before', 'get', key, default=default)
    ... 
    ...     @after('get')
    ...     def after_get(self, key, default=None):
    ...         self._debug('after', 'get', key, default=default)

If hook for function is defined in more than one behavior, they are called in
order of behavior registration.
::
    >>> @behavior(HookBeforeAfterGet, OtherHookBeforeAfterGet)
    ... class BehaviorNode(OrderedNode): pass
    
    >>> node = BehaviorNode('hooked')
    >>> node.get('foo', None)
    * before ``get`` of <HookBeforeAfterGet object at ...> 
      on <BehaviorNode object 'hooked' at ...> 
      with args ``('foo',)`` 
      and kw ``{'default': None}`` ---
    * before ``get`` of <OtherHookBeforeAfterGet object at ...> 
      on <BehaviorNode object 'hooked' at ...> 
      with args ``('foo',)`` 
      and kw ``{'default': None}`` ---
    * after ``get`` of <HookBeforeAfterGet object at ...> 
      on <BehaviorNode object 'hooked' at ...> 
      with args ``('foo',)`` 
      and kw ``{'default': None}`` ---
    * after ``get`` of <OtherHookBeforeAfterGet object at ...> 
      on <BehaviorNode object 'hooked' at ...> 
      with args ``('foo',)`` 
      and kw ``{'default': None}`` ---

Hook data structure related private functions.
::
    >>> class HookBeforeAfterGetItem(BaseBehavior):
    ... 
    ...     @before('__getitem__')
    ...     def before_getitem(self, key):
    ...         self._debug('before', '__getitem__', key)
    ... 
    ...     @after('__getitem__')
    ...     def after_getitem(self, key):
    ...         self._debug('after', '__getitem__', key)
    
    >>> class HookBeforeAfterSetItem(BaseBehavior):
    ... 
    ...     @before('__setitem__')
    ...     def before_setitem(self, key, value):
    ...         self._debug('before', '__setitem__', key, value)
    ... 
    ...     @after('__setitem__')
    ...     def after_setitem(self, key, value):
    ...         self._debug('after', '__setitem__', key, value)
    
    >>> @behavior(HookBeforeAfterGetItem, HookBeforeAfterSetItem)
    ... class BehaviorNode(OrderedNode): pass
    
    >>> node = BehaviorNode('hooked')
    >>> node['foo'] = OrderedNode()
    * before ``__setitem__`` of <HookBeforeAfterSetItem object at ...> 
      on <BehaviorNode object 'hooked' at ...> 
      with args ``('foo', <OrderedNode object 'None' at ...>)`` 
      and kw ``{}`` ---
    * after ``__setitem__`` of <HookBeforeAfterSetItem object at ...> 
      on <BehaviorNode object 'hooked' at ...> 
      with args ``('foo', <OrderedNode object 'foo' at ...>)`` 
      and kw ``{}`` ---
    
    >>> node['foo']
    * before ``__getitem__`` of <HookBeforeAfterGetItem object at ...> 
      on <BehaviorNode object 'hooked' at ...> 
      with args ``('foo',)`` 
      and kw ``{}`` ---
    * after ``__getitem__`` of <HookBeforeAfterGetItem object at ...> 
      on <BehaviorNode object 'hooked' at ...> 
      with args ``('foo',)`` 
      and kw ``{}`` ---
    <OrderedNode object 'foo' at ...>

Remember. The context object on behavior implementation is the behavior 
enhanced node. Test if context access on behavior does not trigger before and 
after handler from within.

Hooked via ``__getattribute__``.
::
    >>> class HookAccessFromWithin(BaseBehavior):
    ... 
    ...     @before('get')
    ...     def before_get(self, key, default=None):
    ...         print 'call ``get`` on ' + str(self.context.get(key)) + \
    ...         ' within behavior hook'
    ...         self._debug('before', 'get', key, default=default)
    
    >>> @behavior(HookAccessFromWithin)
    ... class BehaviorNode(OrderedNode): pass
    
    >>> node = BehaviorNode('hooked')
    >>> node['foo'] = BehaviorNode()
    >>> node.get('foo')
    call ``get`` on <BehaviorNode object 'foo' at ...> within behavior hook
    * before ``get`` of <HookAccessFromWithin object at ...> 
      on <BehaviorNode object 'hooked' at ...> 
      with args ``('foo',)`` 
      and kw ``{'default': None}`` ---
    <BehaviorNode object 'foo' at ...>

Hooked via metaclass constructor.
::
    >>> class OtherHookAccessFromWithin(BaseBehavior):
    ... 
    ...     @before('__getitem__')
    ...     def before_getitem(self, key):
    ...         print 'call ``__getitem__`` on ' + str(self.context[key]) + \
    ...         ' within behavior hook'
    ...         self._debug('before', '__getitem__', key)
    
    >>> @behavior(OtherHookAccessFromWithin)
    ... class BehaviorNode(OrderedNode): pass
    
    >>> node = BehaviorNode('hooked')
    >>> node['foo'] = BehaviorNode()
    >>> node['foo']
    call ``__getitem__`` on <BehaviorNode object 'foo' at ...> within behavior hook
    * before ``__getitem__`` of <OtherHookAccessFromWithin object at ...> 
      on <BehaviorNode object 'hooked' at ...> 
      with args ``('foo',)`` 
      and kw ``{}`` ---
    <BehaviorNode object 'foo' at ...>


Run Testers against wrapper
---------------------------

FullMappingTester.
::

    >>> @behavior(OtherBehavior, SomeBehavior)
    ... class BehaviorNode(OrderedNode):
    ... 
    ...     def do(self):
    ...         return 'do on node ' + str(self)
    
    >>> from node.testing import FullMappingTester
    >>> tester = FullMappingTester(BehaviorNode)
    >>> tester.run()
    >>> tester.combined
    ``__setitem__``: OK
    ``__getitem__``: OK
    ``get``: OK
    ``__iter__``: OK
    ``keys``: OK
    ``iterkeys``: OK
    ``values``: OK
    ``itervalues``: OK
    ``items``: OK
    ``iteritems``: OK
    ``__contains__``: OK
    ``has_key``: OK
    ``__len__``: OK
    ``update``: OK
    ``__delitem__``: OK
    ``copy``: OK
    ``setdefault``: OK
    ``pop``: OK
    ``popitem``: OK
    ``clear``: OK
