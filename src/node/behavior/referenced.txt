node.behavior.referenced
========================

::
    >>> from node.base import OrderedNode
    >>> from node.behavior import behavior
    >>> from node.behavior import Referenced
    
    >>> @behavior(Referenced)
    ... class ReferencedNode(OrderedNode): pass
    
    >>> node = ReferencedNode('referenced')

    >>> node.index
    <node.behavior.referenced.NodeIndex object at ...>

    >>> unindexednode = OrderedNode()
    >>> unindexednode.index
    Traceback (most recent call last):
      ...
    AttributeError: 'OrderedNode' object has no attribute 'index'

    >>> from zope.interface.common.mapping import IReadMapping
    >>> IReadMapping.providedBy(node.index)
    True

    >>> node.index[node.uuid]
    <ReferencedNode object 'referenced' at ...>

    >>> node.index.get(node.uuid)
    <ReferencedNode object 'referenced' at ...>

    >>> node.uuid in node.index
    True

    >>> len(node.index._index)
    1

Add some children and check index.
::
    >>> node['child'] = ReferencedNode()
    >>> node.index._index is node['child'].index._index
    True

    >>> len(node.index._index)
    2

    >>> node['child']['subchild'] = ReferencedNode()
    >>> len(node.index._index)
    3

    >>> node['child']['subchild2'] = ReferencedNode()
    >>> len(node.index._index)
    4

Adding in indexed Node with same uuid or the same node twice fails.
::
    >>> child = node['child']
    >>> node['child2'] = child
    Traceback (most recent call last):
      ...
    ValueError: Node with uuid already exists

Delete non-extistent key
::
    >>> del node['non-existent']
    Traceback (most recent call last):
    ...
    KeyError: 'non-existent'

Check UUID stuff.
::
    >>> len(node.index._index.keys())
    4

    >>> uuid = node['child']['subchild'].uuid
    >>> uuid
    UUID('...')

    >>> node.node(uuid).path
    ['referenced', 'child', 'subchild']

    >>> node.uuid = uuid
    Traceback (most recent call last):
      ...
    ValueError: Given uuid was already used for another Node

    >>> import uuid
    >>> newuuid = uuid.uuid4()

    >>> node.uuid = newuuid
    >>> node['child'].node(newuuid).path
    ['referenced']

    >>> len(node.index._index.keys())
    4

Store the uuids of the nodes which are expected to be deleted from index if
child is deleted.
::
    >>> delindexes = [
    ...     int(node['child'].uuid),
    ...     int(node['child']['subchild'].uuid),
    ...     int(node['child']['subchild2'].uuid),
    ... ]

Read the uuid index and check containment in index.
::
    >>> iuuids = node.index._index.keys()
    >>> len(iuuids)
    4

    >>> delindexes[0] in iuuids
    True

    >>> delindexes[1] in iuuids
    True

    >>> delindexes[2] in iuuids
    True

Delete child. All checked uuids above must be deleted from index.
::
    >>> node.printtree()
    <class 'ReferencedNode'>: referenced
      <class 'ReferencedNode'>: child
        <class 'ReferencedNode'>: subchild
        <class 'ReferencedNode'>: subchild2
    
    >>> old_raw_index = node._raw_node_index()
    >>> len(old_raw_index)
    4
    
    >>> del node['child']
    >>> node.keys()
    []

    >>> new_raw_index = node._raw_node_index()
    >>> old_raw_index is new_raw_index
    True
    
    >>> uuids = new_raw_index.keys()
    >>> len(uuids)
    1

    >>> node.index[node.uuid].context is node
    True

    >>> delindexes[0] in uuids
    False

    >>> delindexes[1] in uuids
    False

    >>> delindexes[2] in uuids
    False

    >>> node.printtree()
    <class 'ReferencedNode'>: referenced
