node.meta
=========

Extending Nodes by different behaviors.


Concepts
--------

- Behavior related functionality is available and directly accessible on node.

- Behavior implementations do not have the behavioral enhanced node as base
  class, but act as an adapter on the node.

- Behaviors are bound to a node by decorator.

- The decorator implementation works with metaclasses.

- Node related functions, attributes and properties always rule, so we can
  overwrite anything on the decorated node, even behavior contract.

- If more than one behavior defines the same attribute or function, return
  first one, analog to the behavior of object inheritance.

### XXX ???

- There are handler hooks for node data structure writing related functions,
  like ``_before___getitem__`` and so on. This way it is possible to overwrite
  data structure modifying functions on wrapper node and hook behaviors, best
  in order of it's definition.


Why using a decorator
---------------------

- It is not possible to custom hook import statements from user pov.

- beside the fact they provide an easy hooking point for manipulating class 
  objects, they are elegant.


Behaviors and the behavior decorator
------------------------------------

Provide a behavior implementation.
::

    >>> from zope.interface import implements
    >>> from node.interfaces import IBehavior
    
    >>> class SomeBehavior(object):
    ...     implements(IBehavior)
    ... 
    ...     def __init__(self, context):
    ...         self.context = context
    ... 
    ...     def do(self):
    ...         return 'do something on ' + str(self.context)
    ... 
    ...     @property
    ...     def prop(self):
    ...         return 'prop'
    ... 
    ...     def _set_rw(self, val):
    ...         self._val = val
    ... 
    ...     def _get_rw(self):
    ...         return self._val
    ... 
    ...     rw = property(_get_rw, _set_rw)

Decorator expects IBehavior implementations.
::

    >>> from node.meta import behavior
    >>> from node.base import OrderedNode
    
    >>> @behavior
    ... class BehaviorNode(OrderedNode):
    ...     pass
    Traceback (most recent call last):
      ...
    TypeError: ``IBehavior`` not implemented by ``BehaviorNode``

    >>> @behavior(dict)
    ... class BehaviorNode(OrderedNode):
    ...     pass
    Traceback (most recent call last):
      ...
    TypeError: ``IBehavior`` not implemented by ``dict``

Decorating none INode implementing classes fails.
::

    >>> @behavior(SomeBehavior)
    ... class BehaviorNode(object):
    ...     pass
    Traceback (most recent call last):
      ...
    TypeError: ``INode`` not implemented by ``BehaviorNode``

Do the right thing.
::

    >>> @behavior(SomeBehavior)
    ... class BehaviorNode(OrderedNode):
    ...     pass

BehavioralNode was wrapped.
::
    
    >>> BehaviorNode
    <class 'node.meta.NodeBehaviorWrapper'>

Behavior classes bound to node.
::

    >>> BehaviorNode.__behaviors_cls
    (<class 'SomeBehavior'>,)

Instanciate wrapped node.
::

    >>> node = BehaviorNode()
    >>> node
    <BehaviorNode object 'None' at ...>

No behavior instances yet. Are created on first attribute access.
::
    
    >>> node.__behaviors_ins
    Traceback (most recent call last):
      ...
    AttributeError: __behaviors_ins

    >>> node.do
    <bound method SomeBehavior.do of <SomeBehavior object at ...>>
    
    >>> node.__behaviors_ins
    {'SomeBehavior': <SomeBehavior object at ...>}

Use behavior functions and properties directly on decorated node.
::

    >>> node.do()
    "do something on <BehaviorNode object 'None' at ...>"
    
    >>> node.prop
    'prop'
    
    >>> node.rw = '123'
    >>> node.rw
    '123'

Define second behavior. It implements ``do`` as well.
::

    >>> class OtherBehavior(object):
    ...     implements(IBehavior)
    ... 
    ...     def __init__(self, context):
    ...         self.context = context
    ... 
    ...     def perform(self):
    ...         return 'perform on ' + str(self.context)
    ... 
    ...     def do(self):
    ...         return 'do other on ' + str(self.context)

Both behaviors using node.
::

    >>> @behavior(SomeBehavior, OtherBehavior)
    ... class BehaviorNode(OrderedNode):
    ...     pass
    
    >>> node = BehaviorNode()
    >>> node.perform
    <bound method OtherBehavior.perform of <OtherBehavior object at ...>>
    
    >>> node.perform()
    "perform on <BehaviorNode object 'None' at ...>"

``do`` is used from SomeBehavior, its first in behavior hierarchy.
::

    >>> node.do
    <bound method SomeBehavior.do of <SomeBehavior object at ...>>

    >>> node.do()
    "do something on <BehaviorNode object 'None' at ...>"

Reversed behavior order.
::

    >>> @behavior(OtherBehavior, SomeBehavior)
    ... class BehaviorNode(OrderedNode):
    ...     pass
    
    >>> node = BehaviorNode()
    >>> node.do
    <bound method OtherBehavior.do of <OtherBehavior object at ...>>
    
    >>> node.do()
    "do other on <BehaviorNode object 'None' at ...>"
    
    >>> node.perform()
    "perform on <BehaviorNode object 'None' at ...>"
    
    >>> node.rw = 'foo'
    >>> node.rw
    'foo'

Override ``do`` on decorated node.
::

    >>> @behavior(OtherBehavior, SomeBehavior)
    ... class BehaviorNode(OrderedNode):
    ... 
    ...     def do(self):
    ...         return 'do on node ' + str(self)
    
    >>> node = BehaviorNode()
    >>> node.do
    <bound method NodeBehaviorWrapper.do of <BehaviorNode object 'None' at ...>>
    
    >>> node.do()
    "do on node <BehaviorNode object 'None' at ...>"


Before and after hooks for behaviors
------------------------------------

    >>> from node.meta import before, after
    
Use hooks in behaviors. signature must be same as hooked function from node
    
    >>> class HookingBehavior(object):
    ...     implements(IBehavior)
    ... 
    ...     def __init__(self, context):
    ...         self.context = context
    ... 
    ...     @before('get')
    ...     def before_get(self, key, default=None):
    ...         print 'before ``get`` on ' + str(self.context) + \
    ...               ' with ' + key
    
    >>> @behavior(HookingBehavior)
    ... class BehaviorNode(OrderedNode): pass
    
    >>> from node.meta import _BEFORE_HOOKS
    >>> from node.meta import _AFTER_HOOKS
    
    >>> _BEFORE_HOOKS
    {'get': [<function before_get at ...>]}
    
    >>> _AFTER_HOOKS
    {}
    
    >>> node = BehaviorNode('hooked')
    >>> node.get('foo', None)
    before ``get`` on <BehaviorNode object 'hooked' at ...> with foo
    
    >>> class OtherHookingBehavior(object):
    ...     implements(IBehavior)
    ... 
    ...     def __init__(self, context):
    ...         self.context = context
    ... 
    ...     @after('get')
    ...     def after_get(self, key, default=None):
    ...         print 'after ``get`` on ' + str(self.context) + \
    ...               ' with ' + key
    
    >>> @behavior(HookingBehavior, OtherHookingBehavior)
    ... class BehaviorNode(OrderedNode): pass
    
    >>> _BEFORE_HOOKS
    {'get': [<function before_get at ...>]}
    
    >>> _AFTER_HOOKS
    {'get': [<function after_get at ...>]}
    
    >>> node = BehaviorNode('hooked')
    >>> node.get('foo', None)
    before ``get`` on <BehaviorNode object 'hooked' at ...> with foo
    after ``get`` on <BehaviorNode object 'hooked' at ...> with foo


Run Testers against wrapper
---------------------------

FullMappingTester.
::

    >>> @behavior(OtherBehavior, SomeBehavior)
    ... class BehaviorNode(OrderedNode):
    ... 
    ...     def do(self):
    ...         return 'do on node ' + str(self)
    
    >>> from node.testing import FullMappingTester
    >>> tester = FullMappingTester(BehaviorNode)
    >>> tester.run()
    >>> tester.combined
    ``__setitem__``: OK
    ``__getitem__``: OK
    ``get``: OK
    ``__iter__``: OK
    ``keys``: OK
    ``iterkeys``: OK
    ``values``: OK
    ``itervalues``: OK
    ``items``: OK
    ``iteritems``: OK
    ``__contains__``: OK
    ``has_key``: OK
    ``__len__``: OK
    ``update``: OK
    ``__delitem__``: OK
    ``copy``: OK
    ``setdefault``: OK
    ``pop``: OK
    ``popitem``: OK
    ``clear``: OK
