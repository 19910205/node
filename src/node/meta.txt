node.meta
=========

Extending Nodes by different behaviors.


Concepts
--------

- Behavior related functionality is available and directly accessible on node.

- Behavior implementations do not have the behavioral enhanced node as base
  class, but act as an adapter on the node.

- Behaviors are bound to a node by decorator.

- The decorator implementation works with metaclasses.

- Node related functions, attributes and properties always rule, so we can
  overwrite anything on the decorated node, even behavior contract.

- If more than one behavior defines the same attribute or function, return
  first one, analog to the behavior of object inheritance.

- Behaviors can hook before and after attribute access of nodes. This is done
  with ``befor`` and ``after`` decorator, which expects name of attribute or
  function to get hooked.


Why using a decorator
---------------------

- It is not possible to custom hook import statements from user pov.

- Beside the fact they provide an easy hooking point for manipulating class 
  objects, they are elegant.


Behaviors and the behavior decorator
------------------------------------

Provide a behavior implementation.
::
    >>> from zope.interface import implements
    >>> from node.interfaces import IBehavior
    >>> from node.meta import BaseBehavior
    
Behaviors are normally not instanciated by the user. This is done by the
behavioral extended Node
::
    
    >>> behavior = BaseBehavior(object())
    >>> behavior.context
    <object object at ...>

Overriding ``context`` on behavior is forbidden.

    >>> behavior.context = 'foo'
    Traceback (most recent call last):
      ...
    RuntimeError: Overriding ``context`` forbidden
    
    >>> class SomeBehavior(BaseBehavior):
    ... 
    ...     def do(self):
    ...         return 'do something on ' + str(self.context)
    ... 
    ...     @property
    ...     def prop(self):
    ...         return 'prop'
    ... 
    ...     def _set_rw(self, val):
    ...         self._val = val
    ... 
    ...     def _get_rw(self):
    ...         return self._val
    ... 
    ...     rw = property(_get_rw, _set_rw)

Decorator expects ``IBehavior`` implementations.
::
    >>> from node.meta import behavior
    >>> from node.base import OrderedNode
    
    >>> @behavior
    ... class SomeBehaviorNode(OrderedNode):
    ...     pass
    Traceback (most recent call last):
      ...
    TypeError: ``IBehavior`` not implemented by ``SomeBehaviorNode``

    >>> @behavior(dict)
    ... class SomeBehaviorNode(OrderedNode):
    ...     pass
    Traceback (most recent call last):
      ...
    TypeError: ``IBehavior`` not implemented by ``dict``

Decorating classes not providing ``INode`` with ``behavior`` will fail.
::
    >>> @behavior(SomeBehavior)
    ... class SomeBehaviorNode(object):
    ...     pass
    Traceback (most recent call last):
      ...
    TypeError: ``INode`` not implemented by ``SomeBehaviorNode``

Do the right thing.
::
    >>> @behavior(SomeBehavior)
    ... class SomeBehaviorNode(OrderedNode):
    ...     pass

Behavioral extended node was wrapped.
::
    >>> SomeBehaviorNode
    <class 'node.meta.NodeBehaviorWrapper'>

Behavior classes bound to node.
::
    >>> SomeBehaviorNode.__behaviors_cls
    (<class 'SomeBehavior'>,)

Instanciate wrapped node.
::
    >>> node = SomeBehaviorNode()
    >>> node
    <SomeBehaviorNode object 'None' at ...>

No behavior instances yet. Are created on first attribute access.
::

    >>> node.__behaviors_ins
    Traceback (most recent call last):
      ...
    AttributeError: __behaviors_ins
    
    >>> node.do
    <bound method SomeBehavior.do of <SomeBehavior object at ...>>
    
    >>> node.__behaviors_ins
    {'SomeBehavior': <SomeBehavior object at ...>}

Use behavior functions and properties directly on decorated node.
::
    >>> node.do()
    "do something on <SomeBehaviorNode object 'None' at ...>"
    
    >>> node.prop
    'prop'
    
    >>> node.rw = '123'
    >>> node.rw
    '123'

Define second behavior. It implements ``do`` as well.
::
    >>> class OtherBehavior(BaseBehavior):
    ... 
    ...     def perform(self):
    ...         return 'perform on ' + str(self.context)
    ... 
    ...     def do(self):
    ...         return 'do other on ' + str(self.context)

Both behaviors extended node.
::
    >>> @behavior(SomeBehavior, OtherBehavior)
    ... class MultiBehaviorNode(OrderedNode):
    ...     pass
    
    >>> node = MultiBehaviorNode()
    >>> node.perform
    <bound method OtherBehavior.perform of <OtherBehavior object at ...>>
    
    >>> node.perform()
    "perform on <MultiBehaviorNode object 'None' at ...>"

``do`` is used from ``SomeBehavior``, its first in behavior hierarchy.
::
    >>> node.do
    <bound method SomeBehavior.do of <SomeBehavior object at ...>>

    >>> node.do()
    "do something on <MultiBehaviorNode object 'None' at ...>"

Reversed behavior order.
::
    >>> @behavior(OtherBehavior, SomeBehavior)
    ... class ReversedMultiBehaviorNode(OrderedNode):
    ...     pass
    
    >>> node = ReversedMultiBehaviorNode()
    >>> node.do
    <bound method OtherBehavior.do of <OtherBehavior object at ...>>
    
    >>> node.do()
    "do other on <ReversedMultiBehaviorNode object 'None' at ...>"
    
    >>> node.perform()
    "perform on <ReversedMultiBehaviorNode object 'None' at ...>"
    
    >>> node.rw = 'foo'
    >>> node.rw
    'foo'

Override ``do`` on decorated node.
::
    >>> @behavior(OtherBehavior, SomeBehavior)
    ... class OverridesBehaviorNode(OrderedNode):
    ... 
    ...     def do(self):
    ...         return 'do on node ' + str(self)
    
    >>> node = OverridesBehaviorNode()
    >>> node.do
    <bound method NodeBehaviorWrapper.do of 
    <OverridesBehaviorNode object 'None' at ...>>
    
    >>> node.do()
    "do on node <OverridesBehaviorNode object 'None' at ...>"


Before and after hooks for behaviors
------------------------------------

Use function hooks in behaviors. Signature of hook function must be same as
of hooked function from node.

Import hook decorators.
::
    >>> from node.meta import before, after

Provide Behavior which hooks before ``node.get``.
::
    >>> class HookBeforeGet(BaseBehavior):
    ... 
    ...     @before('get')
    ...     def before_get(self, key, default=None):
    ...         self._debug('before', 'get', key, default=default)

Decorate a node with hook defining behavior.
::
    >>> @behavior(HookBeforeGet)
    ... class BeforeGetHookedNode(OrderedNode): pass

Hooks are stored in registries.
::
    >>> from node.meta import _BEFORE_HOOKS
    >>> from node.meta import _AFTER_HOOKS
    
    >>> _BEFORE_HOOKS
    {'get': [<function before_get at ...>]}
    
    >>> _AFTER_HOOKS
    {}

Instanciate and check wether hook gets called.
::
    >>> node = BeforeGetHookedNode('hooked')
    >>> node.get('foo', None)
    * before ``get`` of <HookBeforeGet object at ...> 
      on <BeforeGetHookedNode object 'hooked' at ...> 
      with args ``('foo',)`` 
      and kw ``{'default': None}`` ---

Second behavior with after get hook.
::
    >>> class HookAfterGet(BaseBehavior):
    ... 
    ...     @after('get')
    ...     def after_get(self, key, default=None):
    ...         self._debug('after', 'get', key, default=default)
    
    >>> @behavior(HookBeforeGet, HookAfterGet)
    ... class BeforeAfterGetHookedNode(OrderedNode): pass
    
    >>> _BEFORE_HOOKS
    {'get': [<function before_get at ...>]}
    
    >>> _AFTER_HOOKS
    {'get': [<function after_get at ...>]}

Now before hook is called of ``HookBeforeGet``, and after hook is called of
``HookAfterGet``.
::
    >>> node = BeforeAfterGetHookedNode('hooked')
    >>> node.get('foo', None)
    * before ``get`` of <HookBeforeGet object at ...> 
      on <BeforeAfterGetHookedNode object 'hooked' at ...> 
      with args ``('foo',)`` 
      and kw ``{'default': None}`` ---
    * after ``get`` of <HookAfterGet object at ...> 
      on <BeforeAfterGetHookedNode object 'hooked' at ...> 
      with args ``('foo',)`` 
      and kw ``{'default': None}`` ---

Two behaviors both defining before and after get hooks.
::
    >>> class HookBeforeAfterGet(BaseBehavior):
    ... 
    ...     @before('get')
    ...     def before_get(self, key, default=None):
    ...         self._debug('before', 'get', key, default=default)
    ... 
    ...     @after('get')
    ...     def after_get(self, key, default=None):
    ...         self._debug('after', 'get', key, default=default)
    
    >>> class OtherHookBeforeAfterGet(BaseBehavior):
    ... 
    ...     @before('get')
    ...     def before_get(self, key, default=None):
    ...         self._debug('before', 'get', key, default=default)
    ... 
    ...     @after('get')
    ...     def after_get(self, key, default=None):
    ...         self._debug('after', 'get', key, default=default)

If hook for function is defined in more than one behavior, they are called in
order of behavior registration.
::
    >>> @behavior(HookBeforeAfterGet, OtherHookBeforeAfterGet)
    ... class MultiBeforeAfterGetHookedNode(OrderedNode): pass
    
    >>> node = MultiBeforeAfterGetHookedNode('hooked')
    >>> node.get('foo', None)
    * before ``get`` of <HookBeforeAfterGet object at ...> 
      on <MultiBeforeAfterGetHookedNode object 'hooked' at ...> 
      with args ``('foo',)`` 
      and kw ``{'default': None}`` ---
    * before ``get`` of <OtherHookBeforeAfterGet object at ...> 
      on <MultiBeforeAfterGetHookedNode object 'hooked' at ...> 
      with args ``('foo',)`` 
      and kw ``{'default': None}`` ---
    * after ``get`` of <HookBeforeAfterGet object at ...> 
      on <MultiBeforeAfterGetHookedNode object 'hooked' at ...> 
      with args ``('foo',)`` 
      and kw ``{'default': None}`` ---
    * after ``get`` of <OtherHookBeforeAfterGet object at ...> 
      on <MultiBeforeAfterGetHookedNode object 'hooked' at ...> 
      with args ``('foo',)`` 
      and kw ``{'default': None}`` ---


Hook data structure related private functions.
::
    >>> class HookBeforeAfterGetItem(BaseBehavior):
    ... 
    ...     @before('__getitem__')
    ...     def before_getitem(self, key):
    ...         self._debug('before', '__getitem__', key)
    ... 
    ...     @after('__getitem__')
    ...     def after_getitem(self, key):
    ...         self._debug('after', '__getitem__', key)
    
    >>> class HookBeforeAfterSetItem(BaseBehavior):
    ... 
    ...     @before('__setitem__')
    ...     def before_setitem(self, key, value):
    ...         self._debug('before', '__setitem__', key, value)
    ... 
    ...     @after('__setitem__')
    ...     def after_setitem(self, key, value):
    ...         self._debug('after', '__setitem__', key, value)
    
    >>> @behavior(HookBeforeAfterGetItem, HookBeforeAfterSetItem)
    ... class BeforeAfterGetItemHookedNode(OrderedNode): pass
    
    >>> node = BeforeAfterGetItemHookedNode('hooked')
    >>> node['foo'] = BeforeAfterGetItemHookedNode()
    * before ``__setitem__`` of <HookBeforeAfterSetItem object at ...> 
      on <BeforeAfterGetItemHookedNode object 'hooked' at ...> 
      with args ``('foo', <BeforeAfterGetItemHookedNode object 'None' at ...>)`` 
      and kw ``{}`` ---
    * after ``__setitem__`` of <HookBeforeAfterSetItem object at ...> 
      on <BeforeAfterGetItemHookedNode object 'hooked' at ...> 
      with args ``('foo', <BeforeAfterGetItemHookedNode object 'foo' at ...>)`` 
      and kw ``{}`` ---
    
    >>> node['foo']
    * before ``__getitem__`` of <HookBeforeAfterGetItem object at ...> 
      on <BeforeAfterGetItemHookedNode object 'hooked' at ...> 
      with args ``('foo',)`` 
      and kw ``{}`` ---
    * after ``__getitem__`` of <HookBeforeAfterGetItem object at ...> 
      on <BeforeAfterGetItemHookedNode object 'hooked' at ...> 
      with args ``('foo',)`` 
      and kw ``{}`` ---
    <BeforeAfterGetItemHookedNode object 'foo' at ...>
    
    >>> node['foo']['bar'] = OrderedNode()
    * before ``__getitem__`` of <HookBeforeAfterGetItem object at ...> 
      on <BeforeAfterGetItemHookedNode object 'hooked' at ...> 
      with args ``('foo',)`` 
      and kw ``{}`` ---
    * after ``__getitem__`` of <HookBeforeAfterGetItem object at ...> 
      on <BeforeAfterGetItemHookedNode object 'hooked' at ...> 
      with args ``('foo',)`` 
      and kw ``{}`` ---
    * before ``__setitem__`` of <HookBeforeAfterSetItem object at ...> 
      on <BeforeAfterGetItemHookedNode object 'foo' at ...> 
      with args ``('bar', <OrderedNode object 'None' at ...>)`` 
      and kw ``{}`` ---
    * after ``__setitem__`` of <HookBeforeAfterSetItem object at ...> 
      on <BeforeAfterGetItemHookedNode object 'foo' at ...> 
      with args ``('bar', <OrderedNode object 'bar' at ...>)`` 
      and kw ``{}`` ---

Remember. The context object on behavior implementation is the behavior 
enhanced node. Test if context access on behavior does not trigger before and 
after handler from within.

Hooked via ``__getattribute__``.
::
    >>> class HookGetAccessFromWithin(BaseBehavior):
    ... 
    ...     @before('get')
    ...     def before_get(self, key, default=None):
    ...         print 'call ``get`` on ' + str(self.context.get(key)) + \
    ...         ' within behavior hook'
    ...         self._debug('before', 'get', key, default=default)
    
    >>> @behavior(HookGetAccessFromWithin)
    ... class AccessedGetFromWithinNode(OrderedNode): pass
    
    >>> node = AccessedGetFromWithinNode('hooked')
    >>> node['foo'] = OrderedNode()
    >>> node.get('foo')
    call ``get`` on <OrderedNode object 'foo' at ...> within behavior hook
    * before ``get`` of <HookGetAccessFromWithin object at ...> 
      on <AccessedGetFromWithinNode object 'hooked' at ...> 
      with args ``('foo',)`` 
      and kw ``{'default': None}`` ---
    <OrderedNode object 'foo' at ...>

Hooked via metaclass constructor.
::
    >>> class HookGetItemAccessFromWithin(BaseBehavior):
    ... 
    ...     @before('__getitem__')
    ...     def before_getitem(self, key):
    ...         print 'call ``__getitem__`` on ' + str(self.context[key]) + \
    ...         ' within behavior hook'
    ...         self._debug('before', '__getitem__', key)
    
    >>> @behavior(HookGetItemAccessFromWithin)
    ... class AccessedGetItemFromWithinNode(OrderedNode): pass
    
    >>> node = AccessedGetItemFromWithinNode('hooked')
    >>> node['foo'] = OrderedNode()
    >>> node['foo']
    call ``__getitem__`` on <OrderedNode object 'foo' at ...> within behavior hook
    * before ``__getitem__`` of <HookGetItemAccessFromWithin object at ...> 
      on <AccessedGetItemFromWithinNode object 'hooked' at ...> 
      with args ``('foo',)`` 
      and kw ``{}`` ---
    <OrderedNode object 'foo' at ...>

Test hook on function derived and overwritten function.
::
    >>> class HookBeforValues(BaseBehavior):
    ...
    ...     @before('values')
    ...     def before_values(self):
    ...         self._debug('before', 'values')
    
    >>> @behavior(HookBeforValues)
    ... class BeforValuesDerivedHookedNode(OrderedNode): pass
    
    >>> node = BeforValuesDerivedHookedNode('hooked')
    >>> node.values()
    * before ``values`` of <HookBeforValues object at ...> 
      on <BeforValuesDerivedHookedNode object 'hooked' at ...> 
      with args ``()`` 
      and kw ``{}`` ---
    []
    
    >>> @behavior(HookBeforValues)
    ... class BeforValuesOverrideHookedNode(OrderedNode):
    ... 
    ...     def values(self):
    ...         return OrderedNode.values(self)
    
    >>> node = BeforValuesOverrideHookedNode('hooked')
    >>> node['foo'] = OrderedNode()
    >>> node.values()
    * before ``values`` of <HookBeforValues object at ...> 
      on <BeforValuesOverrideHookedNode object 'hooked' at ...> 
      with args ``()`` 
      and kw ``{}`` ---
    [<OrderedNode object 'foo' at ...>]

Test hook on property. Fails! Hooks can only be set on functions.
::
    >>> class HookBeforSomeProp(BaseBehavior):
    ... 
    ...     @before('someprop')
    ...     def before_seomprop(self, name, value=None):
    ...         pass
    
    >>> @behavior(HookBeforSomeProp)
    ... class BeforSomepropHookedNode(OrderedNode):
    ... 
    ...     @property
    ...     def someprop(self):
    ...         return 'foo'
    
    >>> node = BeforSomepropHookedNode('hooked')
    >>> node.someprop
    Traceback (most recent call last):
      ...
    AttributeError: someprop


Run Testers against wrapper
---------------------------

FullMappingTester.
::

    >>> @behavior(OtherBehavior, SomeBehavior)
    ... class BehaviorNode(OrderedNode):
    ... 
    ...     def do(self):
    ...         return 'do on node ' + str(self)
    
    >>> from node.testing import FullMappingTester
    >>> tester = FullMappingTester(BehaviorNode)
    >>> tester.run()
    >>> tester.combined
    ``__setitem__``: OK
    ``__getitem__``: OK
    ``get``: OK
    ``__iter__``: OK
    ``keys``: OK
    ``iterkeys``: OK
    ``values``: OK
    ``itervalues``: OK
    ``items``: OK
    ``iteritems``: OK
    ``__contains__``: OK
    ``has_key``: OK
    ``__len__``: OK
    ``update``: OK
    ``__delitem__``: OK
    ``copy``: OK
    ``setdefault``: OK
    ``pop``: OK
    ``popitem``: OK
    ``clear``: OK
