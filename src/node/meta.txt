node.meta
=========

Extending Nodes by different behaviors.


Concepts
--------

- Behavior related functionality is available and directly accessible on node.

- Behavior implementations do not have the behavioral enhanced node as base
  class, but act as an adapter on the node.

- Behaviors are bound to a node by decorator.

- The decorator implementation works with metaclasses.

- Node related functions, attributes and properties always rule, so we can
  overwrite anything on the decorated node, even behavior contract.

- If more than one behavior defines the same attribute or function, return
  first one, analog to the behavior of object inheritance.

### XXX ???

- There are handler hooks for node data structure writing related functions,
  like ``_before___getitem__`` and so on. This way it is possible to overwrite
  data structure modifying functions on wrapper node and hook behaviors, best
  in order of it's definition.


Why using a decorator
---------------------

- It is not possible to custom hook import statements from user pov.

- beside the fact they provide an easy hooking point for manipulating class 
  objects, they are elegant.


Tests
-----

Provide a behavior implementation.
::

    >>> from zope.interface import implements
    >>> from node.interfaces import IBehavior
    
    >>> class SomeBehavior(object):
    ...     implements(IBehavior)
    ... 
    ...     def __init__(self, context):
    ...         self.context = context
    ... 
    ...     def do(self):
    ...         return 'do something on ' + str(self.context)
    ... 
    ...     @property
    ...     def prop(self):
    ...         return 'prop'
    ... 
    ...     def _set_rw(self, val):
    ...         self._val = val
    ... 
    ...     def _get_rw(self):
    ...         return self._val
    ... 
    ...     rw = property(_get_rw, _set_rw)

Decorator expects IBehavior implementations.
::

    >>> from node.meta import behavior
    >>> from node.base import OrderedNode
    
    >>> @behavior
    ... class BehaviorNode(OrderedNode):
    ...     pass
    Traceback (most recent call last):
      ...
    TypeError: ``IBehavior`` not implemented by ``BehaviorNode``

    >>> @behavior(dict)
    ... class BehaviorNode(OrderedNode):
    ...     pass
    Traceback (most recent call last):
      ...
    TypeError: ``IBehavior`` not implemented by ``dict``

Decorating none INode implementing classes fails.
::

    >>> @behavior(SomeBehavior)
    ... class BehaviorNode(object):
    ...     pass
    Traceback (most recent call last):
      ...
    TypeError: ``INode`` not implemented by ``BehaviorNode``

Do the right thing.
::

    >>> @behavior(SomeBehavior)
    ... class BehaviorNode(OrderedNode):
    ...     pass

BehavioralNode was wrapped.
::
    
    >>> BehaviorNode
    <class 'node.meta.NodeBehaviorWrapper'>

Behavior classes bound to node.
::

    >>> BehaviorNode.__behaviors_cls
    (<class 'SomeBehavior'>,)

Instanciate wrapped node.
::

    >>> node = BehaviorNode()
    >>> node
    <BehaviorNode object 'None' at ...>

No behavior instances yet. Are created on first attribute access.
::
    
    >>> node.__class__.__behaviors_ins
    {}

    >>> node.do
    <bound method SomeBehavior.do of <SomeBehavior object at ...>>
    
    >>> node.__class__.__behaviors_ins
    {'SomeBehavior': <SomeBehavior object at ...>}

Use behavior functions and properties directly on decorated node.
::

    >>> node.do()
    "do something on <BehaviorNode object 'None' at ...>"
    
    >>> node.prop
    'prop'
    
    >>> node.rw = '123'
    >>> node.rw
    '123'

Define second behavior. It implements ``do`` as well.
::

    >>> class OtherBehavior(object):
    ...     implements(IBehavior)
    ... 
    ...     def __init__(self, context):
    ...         self.context = context
    ... 
    ...     def perform(self):
    ...         return 'perform on ' + str(self.context)
    ... 
    ...     def do(self):
    ...         return 'do other on ' + str(self.context)

Both behaviors using node.
::

    >>> @behavior(SomeBehavior, OtherBehavior)
    ... class BehaviorNode(OrderedNode):
    ...     pass
    
    >>> node = BehaviorNode()
    >>> node.perform()
    "perform on <BehaviorNode object 'None' at ...>"

``do`` is used from SomeBehavior, its first in behavior hierarchy.
::

    >>> node.do()
    "do something on <BehaviorNode object 'None' at ...>"

Reversed behavior order.
::

    >>> @behavior(OtherBehavior, SomeBehavior)
    ... class BehaviorNode(OrderedNode):
    ...     pass
    
    >>> node = BehaviorNode()
    >>> node.perform()
    "perform on <BehaviorNode object 'None' at ...>"
    
    >>> node.do()
    "do other on <BehaviorNode object 'None' at ...>"
    
    >>> node.rw = 'foo'
    >>> node.rw
    'foo'


Run FullMappingTester against wrapper.
::

### - remove

    >>> node['foo'] = BehaviorNode()
    >>> node.keys()
    ['foo']
    
    >>> node['bar'] = BehaviorNode(name='xxx')
    >>> node['bar']
    <BehaviorNode object 'bar' at ...>
    
    >>> node['bar'].__name__
    'bar'

/ ### - remove

    >>> from node.testing import FullMappingTester
    >>> tester = FullMappingTester(BehaviorNode)
    >>> tester.run()

BehaviorNode is probably valid...

    >>> tester.combined
    ``__setitem__``: OK
    ``__getitem__``: Failed: <NodeBehaviorWrapper object 'foo' at ...>
    ``get``: Failed: <NodeBehaviorWrapper object 'bar' at ...>
    ``__iter__``: OK
    ``keys``: OK
    ``iterkeys``: OK
    ``values``: OK
    ``itervalues``: OK
    ``items``: Failed: <NodeBehaviorWrapper object 'foo' at ...>
    ``iteritems``: Failed: <NodeBehaviorWrapper object 'foo' at ...>
    ``__contains__``: OK
    ``has_key``: OK
    ``__len__``: OK
    ``update``: Failed: <NodeBehaviorWrapper object 'baz' at ...>
    ``__delitem__``: OK
    ``copy``: Failed: <NodeBehaviorWrapper object 'None' at ...>
    ``setdefault``: Failed: <NodeBehaviorWrapper object 'foo' at ...>
    ``pop``: Failed: Expected ``foo``, got ``foo``
    ``popitem``: OK
    ``clear``: OK