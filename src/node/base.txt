node.base
=========

Helper function for creating identically tree structures from different classes.
::

    >>> def create_tree(class_):
    ...     root = class_()
    ...     for i in range(3):
    ...         root['child_%i' % i] = class_()
    ...         for j in range(2):
    ...             root['child_%i' % i]['subchild_%i' % j] = class_()
    ...     return root


AbstractNode
------------
::

    >>> from node.base import AbstractNode
    >>> AbstractNode
    <class 'node.base.AbstractNode'>
    
    >>> AbstractNode.__bases__
    (<class 'node.base._NodeMixin'>, <class 'node.base._FullMappingMixin'>)
    
    >>> abstract = AbstractNode()
    >>> abstract
    <AbstractNode object 'None' at ...>

Storage related operations of AbstractNode raise ``NotImplementedError``.
::

    >>> abstract['foo']
    Traceback (most recent call last):
      ...
    NotImplementedError
    
    >>> del abstract['foo']
    Traceback (most recent call last):
      ...
    NotImplementedError
    
    >>> abstract['foo'] = 'bar'
    Traceback (most recent call last):
      ...
    NotImplementedError
    
    >>> [key for key in abstract]
    Traceback (most recent call last):
      ...
    NotImplementedError
    
    >>> abstract_copy = abstract.copy()
    Traceback (most recent call last):
      ...
    NotImplementedError
    
    >>> abstract.clear()
    Traceback (most recent call last):
      ...
    NotImplementedError
    
    >>> abstract.update((('foo', 'bar'),))
    Traceback (most recent call last):
      ...
    NotImplementedError
    
    >>> abstract.setdefault('foo', 'bar')
    Traceback (most recent call last):
      ...
    NotImplementedError
    
    >>> abstract.pop('foo')
    Traceback (most recent call last):
      ...
    NotImplementedError
    
    >>> abstract.popitem()
    Traceback (most recent call last):
      ...
    NotImplementedError
    
Subclass ``AbstractNode`` and provide needed functions.

Below we utilize ``odict.odict`` for most of the work. There exists node 
``OrderedNode``, which already uses odict, so for illustration we import odict
as somefullmapping.
::

    >>> import inspect
    >>> from odict import odict as somefullmapping
    >>> from node.interfaces import INode
    >>> class MyNode(AbstractNode, somefullmapping):
    ...     def __init__(self, name=None, parent=None):
    ...         # XXX: using ``super`` on dedicated base class? how?
    ...         somefullmapping.__init__(self)
    ...         AbstractNode.__init__(self, name, parent)
    ... 
    ...     __getitem__ = somefullmapping.__getitem__
    ... 
    ...     __delitem__ = somefullmapping.__delitem__
    ... 
    ...     def __setitem__(self, key, val):
    ...         if not self.allow_non_node_childs and inspect.isclass(val):
    ...             raise ValueError, u"It isn't allowed to use classes as values."
    ...         if not self.allow_non_node_childs and not INode.providedBy(val):
    ...             raise ValueError("Non-node childs are not allowed.")
    ...         if INode.providedBy(val):
    ...             val.__name__ = key
    ...             val.__parent__ = self
    ...         somefullmapping.__setitem__(self, key, val)
    ... 
    ...     __iter__ = somefullmapping.__iter__
    ... 
    ...     clear = somefullmapping.clear
    ... 
    ...     update = somefullmapping.update
    ... 
    ...     setdefault = somefullmapping.setdefault
    ... 
    ...     pop = somefullmapping.pop
    ... 
    ...     popitem = somefullmapping.popitem
    
    >>> mynode = MyNode()
    >>> mynode
    <MyNode object 'None' at ...>


BaseNode
--------
::

    >>> from node.base import BaseNode
    >>> BaseNode
    <class 'node.base.BaseNode'>
    
    >>> BaseNode.__bases__
    (<class 'node.base._NodeSpaceMixin'>, <type 'dict'>)
    
    >>> basenode = BaseNode()
    >>> basenode
    <BaseNode object 'None' at ...>


OrderedNode
-----------
::

    >>> from node.base import OrderedNode
    >>> OrderedNode
    <class 'node.base.OrderedNode'>
    
    >>> OrderedNode.__bases__
    (<class 'node.base._NodeSpaceMixin'>, <class 'odict.pyodict.odict'>)
    
    >>> orderednode = OrderedNode()
    >>> orderednode
    <OrderedNode object 'None' at ...>


IFullMapping contract
---------------------

``__setitem__``

Note if __name__ is set on added node, it gets overwritten by new key
::

    >>> mynode['foo'] = MyNode()
    >>> mynode['bar'] = MyNode(name='xxx')
    >>> basenode['foo'] = BaseNode()
    >>> basenode['bar'] = BaseNode(name='xxx')
    >>> orderednode['foo'] = OrderedNode()
    >>> orderednode['bar'] = OrderedNode(name='xxx')

``__getitem__``
::

    >>> mynode['foo']
    <MyNode object 'foo' at ...>
    
    >>> mynode['bar'].__name__
    'bar'
    
    >>> basenode['foo']
    <BaseNode object 'foo' at ...>
    
    >>> basenode['bar'].__name__
    'bar'
    
    >>> orderednode['foo']
    <OrderedNode object 'foo' at ...>
    
    >>> orderednode['bar'].__name__
    'bar'

``get``
::

    >>> mynode.get('bar')
    <MyNode object 'bar' at ...>
    
    >>> mynode.get('xxx', 'default')
    'default'
    
    >>> basenode.get('bar')
    <BaseNode object 'bar' at ...>
    
    >>> basenode.get('xxx', 'default')
    'default'
    
    >>> orderednode.get('bar')
    <OrderedNode object 'bar' at ...>
    
    >>> orderednode.get('xxx', 'default')
    'default'

``__iter__``
::

    >>> [key for key in mynode]
    ['foo', 'bar']
    
    >>> [key for key in basenode]
    ['foo', 'bar']
    
    >>> [key for key in orderednode]
    ['foo', 'bar']

``keys``
::

    >>> mynode.keys()
    ['foo', 'bar']
    
    >>> basenode.keys()
    ['foo', 'bar']
    
    >>> orderednode.keys()
    ['foo', 'bar']

``iterkeys``
::

    >>> [key for key in mynode.iterkeys()]
    ['foo', 'bar']
    
    >>> [key for key in basenode.iterkeys()]
    ['foo', 'bar']
    
    >>> [key for key in orderednode.iterkeys()]
    ['foo', 'bar']

``values``
::

    >>> mynode.values()
    [<MyNode object 'foo' at ...>, <MyNode object 'bar' at ...>]
    
    >>> basenode.values()
    [<BaseNode object 'foo' at ...>, <BaseNode object 'bar' at ...>]
    
    >>> orderednode.values()
    [<OrderedNode object 'foo' at ...>, <OrderedNode object 'bar' at ...>]

``itervalues``
::

    >>> [val for val in mynode.itervalues()]
    [<MyNode object 'foo' at ...>, <MyNode object 'bar' at ...>]
    
    >>> [val for val in basenode.itervalues()]
    [<BaseNode object 'foo' at ...>, <BaseNode object 'bar' at ...>]
    
    >>> [val for val in orderednode.itervalues()]
    [<OrderedNode object 'foo' at ...>, <OrderedNode object 'bar' at ...>]

``items``
::
    
    >>> mynode.items()
    [('foo', <MyNode object 'foo' at ...>), 
    ('bar', <MyNode object 'bar' at ...>)]
    
    >>> basenode.items()
    [('foo', <BaseNode object 'foo' at ...>), 
    ('bar', <BaseNode object 'bar' at ...>)]
    
    >>> orderednode.items()
    [('foo', <OrderedNode object 'foo' at ...>), 
    ('bar', <OrderedNode object 'bar' at ...>)]

``iteritems``
::

    >>> [item for item in mynode.iteritems()]
    [('foo', <MyNode object 'foo' at ...>), 
    ('bar', <MyNode object 'bar' at ...>)]
    
    >>> [item for item in basenode.iteritems()]
    [('foo', <BaseNode object 'foo' at ...>), 
    ('bar', <BaseNode object 'bar' at ...>)]
    
    >>> [item for item in orderednode.iteritems()]
    [('foo', <OrderedNode object 'foo' at ...>), 
    ('bar', <OrderedNode object 'bar' at ...>)]

``__contains__``
::

    >>> 'bar' in mynode
    True
    
    >>> 'bar' in basenode
    True
    
    >>> 'bar' in orderednode
    True

``has_key``
::

    >>> mynode.has_key('foo')
    True
    
    >>> basenode.has_key('foo')
    True
    
    >>> orderednode.has_key('foo')
    True

``__len__``
::

    >>> len(mynode)
    2
    
    >>> len(basenode)
    2
    
    >>> len(orderednode)
    2

``update``
::

    >>> mynode.update((('baz', MyNode()),))
    >>> mynode['baz']
    <MyNode object 'baz' at ...>
    
    >>> basenode.update((('baz', BaseNode()),))
    >>> basenode['baz']
    <BaseNode object 'baz' at ...>
    
    >>> orderednode.update((('baz', OrderedNode()),))
    >>> orderednode['baz']
    <OrderedNode object 'baz' at ...>

``__delitem__``
::

    >>> del mynode['bar']
    >>> mynode.keys()
    ['foo', 'baz']
    
    >>> del basenode['bar']
    >>> basenode.keys()
    ['baz', 'foo']
    
    >>> del orderednode['bar']
    >>> orderednode.keys()
    ['foo', 'baz']

``copy``
::

    >>> mycopied = mynode.copy()
    >>> mycopied
    <MyNode object 'None' at ...>
    
    >>> mycopied is mynode
    False
    
    >>> mycopied.items()
    [('foo', <MyNode object 'foo' at ...>), 
    ('baz', <MyNode object 'baz' at ...>)]
    
    >>> mycopied['foo'] is mynode['foo']
    True
    
    >>> basecopied = basenode.copy()
    >>> basecopied
    <BaseNode object 'None' at ...>
    
    >>> basecopied is basenode
    False
    
    >>> basecopied.items()
    [('foo', <BaseNode object 'foo' at ...>), 
    ('baz', <BaseNode object 'baz' at ...>)]
    
    >>> basecopied['foo'] is basenode['foo']
    True
    
    >>> orderedcopied = orderednode.copy()
    >>> orderedcopied
    <OrderedNode object 'None' at ...>
    
    >>> orderedcopied is orderednode
    False
    
    >>> orderedcopied.items()
    [('foo', <OrderedNode object 'foo' at ...>), 
    ('baz', <OrderedNode object 'baz' at ...>)]
    
    >>> orderedcopied['foo'] is orderednode['foo']
    True

``setdefault``
::

    >>> mynew = MyNode()
    >>> mynode.setdefault('foo', mynew) is mynew
    False
    
    >>> mynode.setdefault('bar', mynew) is mynew
    True
    
    >>> mynode.items()
    [('foo', <MyNode object 'foo' at ...>), 
    ('baz', <MyNode object 'baz' at ...>), 
    ('bar', <MyNode object 'bar' at ...>)]
    
    >>> basenew = BaseNode()
    >>> basenode.setdefault('foo', basenew) is basenew
    False
    
    >>> basenode.setdefault('bar', basenew) is basenew
    True
    
    >>> basenode.items()
    [('baz', <BaseNode object 'baz' at ...>), 
    ('foo', <BaseNode object 'foo' at ...>), 
    ('bar', <BaseNode object 'None' at ...>)]
    
    >>> orderednew = OrderedNode()
    >>> orderednode.setdefault('foo', orderednew) is orderednew
    False
    
    >>> orderednode.setdefault('bar', orderednew) is orderednew
    True

``pop``
::

    >>> mynode.pop('xxx')
    Traceback (most recent call last):
      ...
    KeyError: 'xxx'
    
    >>> mynode.pop('xxx', 'default')
    'default'
    
    >>> mynode.pop('foo')
    <MyNode object 'foo' at ...>
    
    >>> mynode.keys()
    ['baz', 'bar']
    
    >>> basenode.pop('xxx')
    Traceback (most recent call last):
      ...
    KeyError: 'xxx'
    
    >>> basenode.pop('xxx', 'default')
    'default'
    
    >>> basenode.pop('foo')
    <BaseNode object 'foo' at ...>
    
    >>> basenode.keys()
    ['baz', 'bar']
    
    >>> orderednode.pop('xxx')
    Traceback (most recent call last):
      ...
    KeyError: 'xxx'
    
    >>> orderednode.pop('xxx', 'default')
    'default'
    
    >>> orderednode.pop('foo')
    <OrderedNode object 'foo' at ...>
    
    >>> orderednode.keys()
    ['baz', 'bar']

``popitem`` and ``clear``
::

    >>> mynode.popitem()
    ('bar', <MyNode object 'bar' at ...>)
    
    >>> mynode.keys()
    ['baz']
    
    >>> mynode.clear()
    >>> mynode.keys()
    []
    
    >>> mynode.popitem()
    Traceback (most recent call last):
      ...
    KeyError: "'popitem(): ordered dictionary is empty'"
    
    >>> basenode.popitem()
    ('baz', <BaseNode object 'baz' at ...>)
    
    >>> basenode.keys()
    ['bar']
    
    >>> basenode.clear()
    >>> basenode.keys()
    []
    
    >>> basenode.popitem()
    Traceback (most recent call last):
      ...
    KeyError: 'popitem(): dictionary is empty'
    
    >>> orderednode.popitem()
    ('bar', <OrderedNode object 'bar' at ...>)
    
    >>> orderednode.keys()
    ['baz']
    
    >>> orderednode.clear()
    >>> orderednode.keys()
    []
    
    >>> orderednode.popitem()
    Traceback (most recent call last):
      ...
    KeyError: "'popitem(): ordered dictionary is empty'"


ILocation contract
------------------

``ILocations`` promises ``__name__`` and ``__parent__`` attributes. They are
used to define tree hierarchy.
::

    >>> mynode = create_tree(MyNode)
    >>> mynode
    <MyNode object 'None' at ...>
    
    >>> mynode.__name__
    >>> mynode.__parent__
    
    >>> mynode['child_1'].__name__
    'child_1'
    
    >>> mynode['child_1'].__parent__ is mynode
    True
    
    >>> mynode['child_1']['subchild_1'].__name__
    'subchild_1'
    
    >>> mynode['child_1']['subchild_1'].__parent__.__parent__ is mynode
    True
    
    >>> basenode = create_tree(BaseNode)
    >>> basenode
    <BaseNode object 'None' at ...>
    
    >>> basenode.__name__
    >>> basenode.__parent__
    
    >>> basenode['child_1'].__name__
    'child_1'
    
    >>> basenode['child_1'].__parent__ is basenode
    True
    
    >>> basenode['child_1']['subchild_1'].__name__
    'subchild_1'
    
    >>> basenode['child_1']['subchild_1'].__parent__.__parent__ is basenode
    True
    
    >>> orderednode = create_tree(OrderedNode)
    >>> orderednode
    <OrderedNode object 'None' at ...>

    >>> orderednode.__name__
    >>> orderednode.__parent__
    
    >>> orderednode['child_1'].__name__
    'child_1'
    
    >>> orderednode['child_1'].__parent__ is orderednode
    True
    
    >>> orderednode['child_1']['subchild_1'].__name__
    'subchild_1'
    
    >>> orderednode['child_1']['subchild_1'].__parent__.__parent__ is orderednode
    True


INode contract
--------------

XXX: decide wether ``aliases`` or ``aliaser`` (still dunno) should be kept in
     base interface.

``printtree``

Debug helper
::

    >>> mynode.printtree()
    <class 'MyNode'>: None
      <class 'MyNode'>: child_0
        <class 'MyNode'>: subchild_0
        <class 'MyNode'>: subchild_1
      <class 'MyNode'>: child_1
        <class 'MyNode'>: subchild_0
        <class 'MyNode'>: subchild_1
      <class 'MyNode'>: child_2
        <class 'MyNode'>: subchild_0
        <class 'MyNode'>: subchild_1
    
    >>> basenode.printtree()
    <class 'node.base.BaseNode'>: None
      <class 'node.base.BaseNode'>: child_...
        <class 'node.base.BaseNode'>: subchild_...
        <class 'node.base.BaseNode'>: subchild_...
      <class 'node.base.BaseNode'>: child_...
        <class 'node.base.BaseNode'>: subchild_...
        <class 'node.base.BaseNode'>: subchild_...
      <class 'node.base.BaseNode'>: child_...
        <class 'node.base.BaseNode'>: subchild_...
        <class 'node.base.BaseNode'>: subchild_...
    
    >>> orderednode.printtree()
    <class 'node.base.OrderedNode'>: None
      <class 'node.base.OrderedNode'>: child_0
        <class 'node.base.OrderedNode'>: subchild_0
        <class 'node.base.OrderedNode'>: subchild_1
      <class 'node.base.OrderedNode'>: child_1
        <class 'node.base.OrderedNode'>: subchild_0
        <class 'node.base.OrderedNode'>: subchild_1
      <class 'node.base.OrderedNode'>: child_2
        <class 'node.base.OrderedNode'>: subchild_0
        <class 'node.base.OrderedNode'>: subchild_1

``path``
::

    >>> mynode.__name__ = 'root'
    >>> mynode.path
    ['root']
    
    >>> mynode['child_1']['subchild_1'].path
    ['root', 'child_1', 'subchild_1']
    
    >>> basenode.__name__ = 'root'
    >>> basenode.path
    ['root']
    
    >>> basenode['child_1']['subchild_1'].path
    ['root', 'child_1', 'subchild_1']
    
    >>> orderednode.__name__ = 'root'
    >>> orderednode.path
    ['root']
    
    >>> orderednode['child_1']['subchild_1'].path
    ['root', 'child_1', 'subchild_1']

``root``
::

    >>> mynode['child_1']['subchild_1'].root is mynode
    True
    
    >>> basenode['child_1']['subchild_1'].root is basenode
    True
    
    >>> orderednode['child_1']['subchild_1'].root is orderednode
    True

``allow_non_node_childs``
::

    >>> mynode.allow_non_node_childs
    False
    
    >>> mynode['foo'] = object()
    Traceback (most recent call last):
      ...
    ValueError: Non-node childs are not allowed.
    
    >>> mynode['foo'] = object
    Traceback (most recent call last):
      ...
    ValueError: It isn't allowed to use classes as values.
    
    >>> mynode.allow_non_node_childs = True
    >>> mynode['foo'] = object()
    >>> mynode['foo']
    <object object at ...>
    
    >>> del mynode['foo']
    >>> mynode.allow_non_node_childs = False
    
    >>> basenode.allow_non_node_childs
    False
    
    >>> basenode['foo'] = object()
    Traceback (most recent call last):
      ...
    ValueError: Non-node childs are not allowed.
    
    >>> basenode['foo'] = object
    Traceback (most recent call last):
      ...
    ValueError: It isn't allowed to use classes as values.
    
    >>> basenode.allow_non_node_childs = True
    >>> basenode['foo'] = object()
    >>> basenode['foo']
    <object object at ...>
    
    >>> del basenode['foo']
    >>> basenode.allow_non_node_childs = False
    
    >>> orderednode.allow_non_node_childs
    False
    
    >>> orderednode['foo'] = object()
    Traceback (most recent call last):
      ...
    ValueError: Non-node childs are not allowed.
    
    >>> orderednode['foo'] = object
    Traceback (most recent call last):
      ...
    ValueError: It isn't allowed to use classes as values.
    
    >>> orderednode.allow_non_node_childs = True
    >>> orderednode['foo'] = object()
    >>> orderednode['foo']
    <object object at ...>
    
    >>> del orderednode['foo']
    >>> orderednode.allow_non_node_childs = False

``filteredvalues``
::

    >>> from zope.interface import Interface, directlyProvides, noLongerProvides
    >>> class IFilter(Interface):
    ...     pass
    
    >>> directlyProvides(mynode['child_2'], IFilter)
    >>> list(mynode.filteredvalues(IFilter))
    [<MyNode object 'child_2' at ...>]
    
    >>> noLongerProvides(mynode['child_2'], IFilter)
    >>> list(mynode.filteredvalues(IFilter))
    []
    
    >>> directlyProvides(basenode['child_2'], IFilter)
    >>> list(basenode.filteredvalues(IFilter))
    [<BaseNode object 'child_2' at ...>]
    
    >>> noLongerProvides(basenode['child_2'], IFilter)
    >>> list(basenode.filteredvalues(IFilter))
    []
    
    >>> directlyProvides(orderednode['child_2'], IFilter)
    >>> list(orderednode.filteredvalues(IFilter))
    [<OrderedNode object 'child_2' at ...>]
    
    >>> noLongerProvides(orderednode['child_2'], IFilter)
    >>> list(orderednode.filteredvalues(IFilter))
    []

``as_attribute_access``
::

    >>> myattrs = mynode.as_attribute_access()
    >>> myattrs
    <node.utils.AttributeAccess object at ...>
    
    >>> myattrs.child_1
    <MyNode object 'child_1' at ...>
    
    >>> myattrs.child_3 = MyNode()
    >>> mynode['child_3']
    <MyNode object 'child_3' at ...>
    
    >>> myattrs.child_4 = object
    Traceback (most recent call last):
      ...
    ValueError: It isn't allowed to use classes as values.
    
    >>> baseattrs = basenode.as_attribute_access()
    >>> baseattrs
    <node.utils.AttributeAccess object at ...>
    
    >>> baseattrs.child_1
    <BaseNode object 'child_1' at ...>
    
    >>> baseattrs.child_3 = BaseNode()
    >>> basenode['child_3']
    <BaseNode object 'child_3' at ...>
    
    >>> baseattrs.child_4 = object
    Traceback (most recent call last):
      ...
    ValueError: It isn't allowed to use classes as values.
    
    >>> orderedattrs = orderednode.as_attribute_access()
    >>> orderedattrs
    <node.utils.AttributeAccess object at ...>
    
    >>> orderedattrs.child_1
    <OrderedNode object 'child_1' at ...>
    
    >>> orderedattrs.child_3 = OrderedNode()
    >>> orderednode['child_3']
    <OrderedNode object 'child_3' at ...>
    
    >>> orderedattrs.child_4 = object
    Traceback (most recent call last):
      ...
    ValueError: It isn't allowed to use classes as values.


Tester Objects
==============

FullMappingTester
-----------------
::

    >>> from node.testing import FullMappingTester
    >>> tester = FullMappingTester(MyNode)
    >>> tester.run()
    >>> tester.combined_results()
    ``__setitem__``: OK
    ``__getitem__``: OK
    ``get``: OK
    ``__iter__``: OK
    ``keys``: OK
    ``iterkeys``: OK
    ``values``: OK
    ``itervalues``: OK
    ``items``: OK
    ``iteritems``: OK
    ``__contains__``: OK
    ``has_key``: OK
    ``__len__``: OK
    ``update``: OK
    ``__delitem__``: OK
    ``copy``: OK


LocationTester
--------------
::

    >>> from node.testing import LocationTester


NodeTester
----------
::

    >>> from node.testing import NodeTester
