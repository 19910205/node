node.behavior.orderable
=======================

::
    >>> from node.base import OrderedNode
    >>> from node.behavior import behavior
    >>> from node.behavior import Orderable
    
    >>> @behavior(Orderable)
    ... class OrderableNode(OrderedNode): pass

    >>> node = OrderableNode('orderable')
    
Node insertion. There exist an ``insertbefore`` and ``insertafter`` function.
::
    >>> node['child1'] = OrderableNode()
    >>> node['child2'] = OrderableNode()
    >>> node.printtree()
    <class 'OrderableNode'>: orderable
      <class 'OrderableNode'>: child1
      <class 'OrderableNode'>: child2

    >>> new = OrderableNode()
    >>> node.insertbefore(new, node['child1'])
    Traceback (most recent call last):
      ...
    ValueError: Given node has no __name__ set.

###

    >>> #node.insertbefore(node['child2'], node['child1'])
    #Traceback (most recent call last):
    #  ...
    #KeyError: u'Given node already contained in tree.'

###

    >>> new.__name__ = 'child3'
    >>> node.insertbefore(new, node['child2'])
    >>> node.printtree()
    <class 'OrderableNode'>: orderable
      <class 'OrderableNode'>: child1
      <class 'OrderableNode'>: child3
      <class 'OrderableNode'>: child2

    >>> new = OrderableNode('child4')
    >>> node.insertafter(new, node['child3'])
    >>> node.printtree()
    <class 'OrderableNode'>: orderable
      <class 'OrderableNode'>: child1
      <class 'OrderableNode'>: child3
      <class 'OrderableNode'>: child4
      <class 'OrderableNode'>: child2

    >>> new = OrderableNode('child5')
    >>> node.insertafter(new, node['child2'])
    >>> node.printtree()
    <class 'OrderableNode'>: orderable
      <class 'OrderableNode'>: child1
      <class 'OrderableNode'>: child3
      <class 'OrderableNode'>: child4
      <class 'OrderableNode'>: child2
      <class 'OrderableNode'>: child5

Move a node. Therefor we first need to detach the node we want to move from
tree. Then insert the detached node elsewhere. In general, you can insert the
detached node or subtree to a complete different tree.
::
    >>> #len(node._index.keys())
    #6

    >>> detached = node.detach('child4')
    >>> detached
    <OrderableNode object 'child4' at ...>

    >>> #len(detached._index.keys())
    #1
    >>> #len(node._index.keys())
    #5

    >>> len(node.values())
    4
    
    >>> node.printtree()
    <class 'OrderableNode'>: orderable
      <class 'OrderableNode'>: child1
      <class 'OrderableNode'>: child3
      <class 'OrderableNode'>: child2
      <class 'OrderableNode'>: child5

    >>> detached.__name__
    'child4'
    
    >>> node['child1']
    <OrderableNode object 'child1' at ...>
    
    >>> node.insertbefore(detached, node['child1'])
    
    >>> node.keys()
    ['child1', 'child3', 'child2', 'child5']
    
    >>> from odict import odict
    >>> odict.keys(node)
    ['child1', 'child3', 'child2', 'child5']
    
    >>> dict.keys(node)
    ['child1', 'child2', 'child3', 'child4', 'child5']
    
    >>> #node.printtree()
    <class 'node.bbb.Node'>: root
      <class 'node.bbb.Node'>: child4
      <class 'node.bbb.Node'>: child1
      <class 'node.bbb.Node'>: child3
      <class 'node.bbb.Node'>: child2
      <class 'node.bbb.Node'>: child5

Merge 2 Node Trees.
::
    >>> #tree1 = Node()
    >>> #tree1['a'] = Node()
    >>> #tree1['b'] = Node()
    >>> #tree2 = Node()
    >>> #tree2['d'] = Node()
    >>> #tree2['e'] = Node()
    >>> #tree1._index is tree2._index
    False

    >>> #len(tree1._index.keys())
    3

    >>> #tree1.printtree()
    <class 'node.bbb.Node'>: None
      <class 'node.bbb.Node'>: a
      <class 'node.bbb.Node'>: b

    >>> #len(tree2._index.keys())
    3

    >>> #tree2.printtree()
    <class 'node.bbb.Node'>: None
      <class 'node.bbb.Node'>: d
      <class 'node.bbb.Node'>: e

    >>> #tree1['c'] = tree2
    >>> #len(tree1._index.keys())
    6

    >> sorted(tree1._index.values(), key=lambda x: x.__name__)

    >>> #tree1._index is tree2._index
    True

    >>> #tree1.printtree()
    <class 'node.bbb.Node'>: None
      <class 'node.bbb.Node'>: a
      <class 'node.bbb.Node'>: b
      <class 'node.bbb.Node'>: c
        <class 'node.bbb.Node'>: d
        <class 'node.bbb.Node'>: e

Detach subtree and insert elsewhere.
::
    >>> #sub = tree1.detach('c')
    >>> #sub.printtree()
    <class 'node.bbb.Node'>: c
      <class 'node.bbb.Node'>: d
      <class 'node.bbb.Node'>: e

    >>> #tree1._index is sub._index
    False

    >>> #sub._index is sub['d']._index is sub['e']._index
    True

    >>> #len(sub._index.keys())
    3

    >>> #tree1.printtree()
    <class 'node.bbb.Node'>: None
      <class 'node.bbb.Node'>: a
      <class 'node.bbb.Node'>: b

    >>> #len(tree1._index.keys())
    3

    >>> #sub.__name__ = 'x'
    >>> #tree1.insertbefore(sub, tree1['a'])
    >>> #tree1.printtree()
    <class 'node.bbb.Node'>: None
      <class 'node.bbb.Node'>: x
        <class 'node.bbb.Node'>: d
        <class 'node.bbb.Node'>: e
      <class 'node.bbb.Node'>: a
      <class 'node.bbb.Node'>: b

    >>> #tree1._index is sub._index
    True

    >>> #len(tree1._index.keys())
    6

    >>> #tree1.insertbefore(sub, tree1['a'])
    Traceback (most recent call last):
      ...
    KeyError: u'Given node already contained in tree.'