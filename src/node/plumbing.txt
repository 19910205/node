Generally needed things
::
    >>> from plumber import Plumber

A mockup node and normal class used to test things only performed on nodes.
::
    >>> from node.interfaces import INode
    >>> from zope.interface import implements
    >>> class MockupNode(object):
    ...     implements(INode)
    ...     __name__ = None
    ...     __parent__ = None

    >>> class NoNode(object):
    ...     pass

Adopt plumbing
--------------

A dictionary is used as end point 
::
    >>> from node.plumbing import Adopt
    >>> class AdoptingDict(dict):
    ...     __metaclass__ = Plumber
    ...     __pipeline__ = (Adopt,)

    >>> ad = AdoptingDict()

The mockup node is adopted
::
    >>> node = MockupNode()
    >>> ad['foo'] = node
    >>> ad['foo'] is node
    True
    >>> node.__name__
    'foo'
    >>> node.__parent__ is ad
    True

The non-node object is not adopted
::
    >>> nonode = NoNode()
    >>> ad['bar'] = nonode
    >>> ad['bar'] is nonode
    True
    >>> hasattr(nonode, '__name__')
    False
    >>> hasattr(nonode, '__parent__')
    False

If something goes wrong, the adoption does not happen.  See plumbing.Adopt for
exceptions that are handled.

XXX: In case this should be configurable, it would be nice if a plumbing
element could be instatiated which is currently not possible. It would be
possible by defining the plumbing __init__ method with a different name.
Maybe it is also possible to have two __init__ one decorated one not, if the
plumbing decorator could influence that all plumbing functions are stored under
a different name. If the decorator cannot do that a Plumbing metaclass will
work for sure, however, it is questionable whether it justifies a metaclass
instead of just naming the plumbing init eg plumbing__init__.
::

    >>> class FakeDict(object):
    ...     def __setitem__(self, key, val):
    ...         raise KeyError(key)

    >>> class FailingAD(FakeDict):
    ...     __metaclass__ = Plumber
    ...     __pipeline__ = (Adopt,)

    >>> fail = FailingAD()
    >>> node = MockupNode()
    >>> fail['foo'] = node
    Traceback (most recent call last):
    ...
    KeyError: 'foo'
    >>> node.__name__ is None
    True
    >>> node.__parent__ is None
    True


Alias plumbing
--------------

A dictionary that uses the alias plumbing but does not assign an aliaser.
Therefore, no aliasing is happening.
::

    >>> from node.plumbing import Alias
    >>> class AliasDict(dict):
    ...     __metaclass__ = Plumber
    ...     __pipeline__ = (Alias,)

    >>> ad = AliasDict()
    >>> ad['foo'] = 1
    >>> ad['foo']
    1
    >>> [x for x in ad]
    ['foo']
    >>> del ad['foo']
    >>> [x for x in ad]
    []

Now the same but with a prefix aliaser.
::

    >>> from node.aliasing import PrefixAliaser
    >>> aliaser = PrefixAliaser(prefix="pre-")
    >>> ad = AliasDict(aliaser=aliaser)
    >>> ad['pre-foo'] = 1
    >>> ad['pre-foo']
    1
    >>> [x for x in ad]
    ['pre-foo']
    >>> del ad['pre-foo']
    >>> [x for x in ad]
    []

KeyErrors in the backend are caught and reraised with the value of the aliased
key.
::

    >>> class FakeDict(object):
    ...     def __delitem__(self, key):
    ...         raise KeyError(key)
    ...     def __getitem__(self, key):
    ...         raise KeyError(key)
    ...     def __iter__(self):
    ...         yield 'foo'
    ...     def __setitem__(self, key, val):
    ...         raise KeyError(key)

    >>> class FailDict(FakeDict):
    ...     __metaclass__ = Plumber
    ...     __pipeline__ = (Alias,)

    >>> fail = FailDict(aliaser=aliaser)
    >>> fail['pre-foo'] = 1
    Traceback (most recent call last):
    ...
    KeyError: 'pre-foo'

    >>> fail['pre-foo']
    Traceback (most recent call last):
    ...
    KeyError: 'pre-foo'

    >>> del fail['pre-foo']
    Traceback (most recent call last):
    ...
    KeyError: 'pre-foo'

A prefix aliaser cannot raise a KeyError, nevertheless, if it does, that error
must not be caught by the code that handle alias KeyErrors for whitelisting
(see below).
::

    >>> def failalias(key):
    ...     raise KeyError
    >>> fail.aliaser.alias = failalias
    >>> [x for x in fail]
    Traceback (most recent call last):
    ...
    KeyError

    >>> from node.aliasing import DictAliaser
    >>> dictaliaser = DictAliaser(data=(('foo', 'f00'), ('bar', 'b4r')))

    >>> ad = AliasDict(aliaser=dictaliaser)
    >>> ad['foo'] = 1
    >>> [x for x in ad]
    ['foo']

Let's put a key in the dict, that is not mapped by the dictionary aliaser. This
is not possible through the plumbing ``__setitem__``, we need to use
``dict.__setitem``.
::

    >>> ad['abc'] = 1
    Traceback (most recent call last):
    ...
    KeyError: 'abc'

    >>> dict.__setitem__(ad, 'abc', 1)
    >>> [x for x in ad]
    ['foo']

To see the keys that are really in the dictionary, we use ``dict.__iter__``,
not the plumbing ``__iter__``.
::

    >>> [x for x in dict.__iter__(ad)]
    ['abc', 'f00']
