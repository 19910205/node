node.meta
=========

Extending Nodes by different behaviors.


Concepts
--------

- Behavior related functionality is available and directly accessible on node.

- Behavior implementations do not have the behavioral enhanced node as base
  class, but act as an adapter on the node.

- Behaviors are bound to a node by decorator.

- The decorator implementation works with metaclasses.

- Node related functions, attributes and properties always rule, so we can
  overwrite anything on the decorated node, even behavior contract.

- If more than one behavior defines the same attribute or function, return
  first one, analog to the behavior of object inheritance.

- Behaviors can hook before and after attribute access of nodes. This is done
  with ``befor`` and ``after`` decorator, which expects name of attribute or
  function to get hooked.


Why using a decorator
---------------------

- It is not possible to custom hook import statements from user pov.

- Beside the fact they provide an easy hooking point for manipulating class 
  objects, they are elegant.


Behaviors and the behavior decorator
------------------------------------

Provide a behavior implementation.
::
    >>> from zope.interface import implements
    >>> from node.interfaces import IBehavior
    >>> from node.meta import BaseBehavior
    
Behaviors are normally not instanciated by the user. This is done by the
behavioral extended Node
::
    
    >>> behavior = BaseBehavior(object())
    >>> behavior.context
    <object object at ...>

Overriding ``context`` on behavior is forbidden.

    >>> behavior.context = 'foo'
    Traceback (most recent call last):
      ...
    RuntimeError: Overriding ``context`` forbidden
    
    >>> class SomeBehavior(BaseBehavior):
    ...
    ...     _val = 'from behavior'
    ... 
    ...     def do(self):
    ...         return 'do something on ' + str(self.context)
    ... 
    ...     @property
    ...     def prop(self):
    ...         return 'prop'
    ... 
    ...     def _set_rw(self, val):
    ...         self._val = val
    ... 
    ...     def _get_rw(self):
    ...         return self._val
    ... 
    ...     rw = property(_get_rw, _set_rw)

Decorator expects ``IBehavior`` implementations.
::
    >>> from node.meta import behavior
    >>> from node.base import OrderedNode
    
XXX: this should probably be @behavior()

    >>> @behavior
    ... class SomeBehaviorNode(OrderedNode):
    ...     pass
    Traceback (most recent call last):
      ...
    TypeError: ``IBehavior`` not implemented by ``SomeBehaviorNode``

    >>> @behavior(dict)
    ... class SomeBehaviorNode(OrderedNode):
    ...     pass
    Traceback (most recent call last):
      ...
    TypeError: ``IBehavior`` not implemented by ``dict``

Decorating classes not providing ``INode`` with ``behavior`` will fail.
::
    >>> @behavior(SomeBehavior)
    ... class SomeBehaviorNode(object):
    ...     pass
    Traceback (most recent call last):
      ...
    TypeError: ``INode`` not implemented by ``SomeBehaviorNode``

Do the right thing.
::
    >>> @behavior(SomeBehavior)
    ... class SomeBehaviorNode(OrderedNode):
    ...     pass

Behavioral extended node was wrapped.
::
    >>> SomeBehaviorNode
    <class 'node.meta.NodeBehaviorWrapper'>

Behavior classes bound to node.
::
    >>> SomeBehaviorNode.__behaviors_cls
    (<class 'SomeBehavior'>,)

Instanciate wrapped node.
::
    >>> node = SomeBehaviorNode()
    >>> node
    <SomeBehaviorNode object 'None' at ...>

    >>> node.do
    <bound method SomeBehavior.do of <SomeBehavior object at ...>>
    
    >>> node._behavior_instances
    odict([('SomeBehavior', <SomeBehavior object at ...>)])

Use behavior functions and properties directly on decorated node.
::
    >>> node.do()
    "do something on <SomeBehaviorNode object 'None' at ...>"
    
    >>> node.prop
    'prop'

``rw`` was implemented as getter/setter propery. Since we have not exposed
this property for write access due to node yet, setting rw to node will write to
node, and return the one from node on next access.
::
    >>> node.rw
    'from behavior'

    >>> node.rw = '123'
    >>> node.rw
    '123'
    
    >>> node.__behaviors_ins['SomeBehavior'].rw
    'from behavior'
    
Now expose ``rw`` for writing. Note that a write exposed attribute must be
implemented as getter/setter property.
::
    >>> class BehaviorWriteExposed(SomeBehavior):
    ...     expose_write_access_for = ['rw']
    
    >>> @behavior(BehaviorWriteExposed)
    ... class WriteExposedBehaviorNode(OrderedNode):
    ...     pass
    
    >>> node = WriteExposedBehaviorNode()
    >>> node.rw = '123'
    >>> node.rw
    '123'
    
    >>> node._behavior_instances['BehaviorWriteExposed'].rw
    '123'

Define second behavior. It implements ``do`` as well.
::
    >>> class OtherBehavior(BaseBehavior):
    ... 
    ...     def perform(self):
    ...         return 'perform on ' + str(self.context)
    ... 
    ...     def do(self):
    ...         return 'do other on ' + str(self.context)

Both behaviors extended node.
::
    >>> @behavior(SomeBehavior, OtherBehavior)
    ... class MultiBehaviorNode(OrderedNode):
    ...     pass
    
    >>> node = MultiBehaviorNode()
    >>> node.perform
    <bound method OtherBehavior.perform of <OtherBehavior object at ...>>
    
    >>> node.perform()
    "perform on <MultiBehaviorNode object 'None' at ...>"

``do`` is used from ``SomeBehavior``, its first in behavior hierarchy.
::
    >>> node.do
    <bound method SomeBehavior.do of <SomeBehavior object at ...>>

    >>> node.do()
    "do something on <MultiBehaviorNode object 'None' at ...>"

Reversed behavior order.
::
    >>> @behavior(OtherBehavior, SomeBehavior)
    ... class ReversedMultiBehaviorNode(OrderedNode):
    ...     pass
    
    >>> node = ReversedMultiBehaviorNode()
    >>> node.do
    <bound method OtherBehavior.do of <OtherBehavior object at ...>>
    
    >>> node.do()
    "do other on <ReversedMultiBehaviorNode object 'None' at ...>"
    
    >>> node.perform()
    "perform on <ReversedMultiBehaviorNode object 'None' at ...>"
    
    >>> node.rw = 'foo'
    >>> node.rw
    'foo'

Override ``do`` on decorated node.
::
    >>> @behavior(OtherBehavior, SomeBehavior)
    ... class OverridesBehaviorNode(OrderedNode):
    ... 
    ...     def do(self):
    ...         return 'do on node ' + str(self)
    
    >>> node = OverridesBehaviorNode()
    >>> node.do
    <bound method NodeBehaviorWrapper.do of 
    <OverridesBehaviorNode object 'None' at ...>>
    
    >>> node.do()
    "do on node <OverridesBehaviorNode object 'None' at ...>"


Before and after hooks for behaviors
------------------------------------

Use function hooks in behaviors. Signature of hook function must be same as
of hooked function from node.

Import hook decorators.
::
    >>> from node.meta import before, after

Provide Behavior which hooks before ``node.get``.
::
    >>> class HookBeforeGet(BaseBehavior):
    ... 
    ...     @before('get')
    ...     def before_get(self, key, default=None):
    ...         self._debug('before', 'get', key, default=default)

Decorate a node with hook defining behavior.
::
    >>> @behavior(HookBeforeGet)
    ... class BeforeGetHookedNode(OrderedNode): pass

Hooks are stored in registries.
::

    >>> from node.meta import _BEFORE_HOOKS
    >>> from node.meta import _AFTER_HOOKS
    
    >>> _BEFORE_HOOKS
    {...}
    
    >>> _AFTER_HOOKS
    {...}

Instanciate and check wether hook gets called.
::
    >>> node = BeforeGetHookedNode('hooked')
    >>> node.get('foo', None)
    * before ``get`` of <HookBeforeGet object at ...> 
      on <BeforeGetHookedNode object 'hooked' at ...> 
      with args ``('foo',)`` 
      and kw ``{'default': None}`` ---

    >>> node.get('bar', None)
    * before ``get`` of <HookBeforeGet object at ...> 
      on <BeforeGetHookedNode object 'hooked' at ...> 
      with args ``('bar',)`` 
      and kw ``{'default': None}`` ---

Second behavior with after get hook.
::
    >>> class HookAfterGet(BaseBehavior):
    ... 
    ...     @after('get')
    ...     def after_get(self, key, default=None):
    ...         self._debug('after', 'get', key, default=default)
    
    >>> @behavior(HookBeforeGet, HookAfterGet)
    ... class BeforeAfterGetHookedNode(OrderedNode): pass

Now before hook is called of ``HookBeforeGet``, and after hook is called of
``HookAfterGet``.
::
    >>> node = BeforeAfterGetHookedNode('hooked')
    >>> node.get('foo', None)
    * before ``get`` of <HookBeforeGet object at ...> 
      on <BeforeAfterGetHookedNode object 'hooked' at ...> 
      with args ``('foo',)`` 
      and kw ``{'default': None}`` ---
    * after ``get`` of <HookAfterGet object at ...> 
      on <BeforeAfterGetHookedNode object 'hooked' at ...> 
      with args ``('foo',)`` 
      and kw ``{'default': None}`` ---

Two behaviors both defining before and after get hooks.
::
    >>> class HookBeforeAfterGet(BaseBehavior):
    ... 
    ...     @before('get')
    ...     def before_get(self, key, default=None):
    ...         self._debug('before', 'get', key, default=default)
    ... 
    ...     @after('get')
    ...     def after_get(self, key, default=None):
    ...         self._debug('after', 'get', key, default=default)
    
    >>> class OtherHookBeforeAfterGet(BaseBehavior):
    ... 
    ...     @before('get')
    ...     def before_get(self, key, default=None):
    ...         self._debug('before', 'get', key, default=default)
    ... 
    ...     @after('get')
    ...     def after_get(self, key, default=None):
    ...         self._debug('after', 'get', key, default=default)

If hook for function is defined in more than one behavior, they are called in
order of behavior registration.
::
    >>> @behavior(HookBeforeAfterGet, OtherHookBeforeAfterGet)
    ... class MultiBeforeAfterGetHookedNode(OrderedNode): pass
    
    >>> node = MultiBeforeAfterGetHookedNode('hooked')
    >>> node.get('foo', None)
    * before ``get`` of <HookBeforeAfterGet object at ...> 
      on <MultiBeforeAfterGetHookedNode object 'hooked' at ...> 
      with args ``('foo',)`` 
      and kw ``{'default': None}`` ---
    * before ``get`` of <OtherHookBeforeAfterGet object at ...> 
      on <MultiBeforeAfterGetHookedNode object 'hooked' at ...> 
      with args ``('foo',)`` 
      and kw ``{'default': None}`` ---
    * after ``get`` of <HookBeforeAfterGet object at ...> 
      on <MultiBeforeAfterGetHookedNode object 'hooked' at ...> 
      with args ``('foo',)`` 
      and kw ``{'default': None}`` ---
    * after ``get`` of <OtherHookBeforeAfterGet object at ...> 
      on <MultiBeforeAfterGetHookedNode object 'hooked' at ...> 
      with args ``('foo',)`` 
      and kw ``{'default': None}`` ---

Hook data structure related private functions.
::
    >>> class HookBeforeAfterGetItem(BaseBehavior):
    ... 
    ...     @before('__getitem__')
    ...     def before_getitem(self, key):
    ...         self._debug('before', '__getitem__', key)
    ... 
    ...     @after('__getitem__')
    ...     def after_getitem(self, key):
    ...         self._debug('after', '__getitem__', key)
    
    >>> class HookBeforeAfterSetItem(BaseBehavior):
    ... 
    ...     @before('__setitem__')
    ...     def before_setitem(self, key, value):
    ...         self._debug('before', '__setitem__', key, value)
    ... 
    ...     @after('__setitem__')
    ...     def after_setitem(self, key, value):
    ...         self._debug('after', '__setitem__', key, value)
    
    >>> @behavior(HookBeforeAfterGetItem, HookBeforeAfterSetItem)
    ... class BeforeAfterGetItemHookedNode(OrderedNode): pass
    
    >>> node = BeforeAfterGetItemHookedNode('hooked')
    >>> node['foo'] = BeforeAfterGetItemHookedNode()
    * before ``__setitem__`` of <HookBeforeAfterSetItem object at ...> 
      on <BeforeAfterGetItemHookedNode object 'hooked' at ...> 
      with args ``('foo', <BeforeAfterGetItemHookedNode object 'None' at ...>)`` 
      and kw ``{}`` ---
    * after ``__setitem__`` of <HookBeforeAfterSetItem object at ...> 
      on <BeforeAfterGetItemHookedNode object 'hooked' at ...> 
      with args ``('foo', <BeforeAfterGetItemHookedNode object 'foo' at ...>)`` 
      and kw ``{}`` ---
    
    >>> node['bar'] = BeforeAfterGetItemHookedNode()
    * before ``__setitem__`` of <HookBeforeAfterSetItem object at ...> 
      on <BeforeAfterGetItemHookedNode object 'hooked' at ...> 
      with args ``('bar', <BeforeAfterGetItemHookedNode object 'None' at ...>)`` 
      and kw ``{}`` ---
    * after ``__setitem__`` of <HookBeforeAfterSetItem object at ...> 
      on <BeforeAfterGetItemHookedNode object 'hooked' at ...> 
      with args ``('bar', <BeforeAfterGetItemHookedNode object 'bar' at ...>)`` 
      and kw ``{}`` ---
    
    >>> node['foo']
    * before ``__getitem__`` of <HookBeforeAfterGetItem object at ...> 
      on <BeforeAfterGetItemHookedNode object 'hooked' at ...> 
      with args ``('foo',)`` 
      and kw ``{}`` ---
    * after ``__getitem__`` of <HookBeforeAfterGetItem object at ...> 
      on <BeforeAfterGetItemHookedNode object 'hooked' at ...> 
      with args ``('foo',)`` 
      and kw ``{}`` ---
    <BeforeAfterGetItemHookedNode object 'foo' at ...>
    
    >>> node['foo']['bar'] = OrderedNode()
    * before ``__getitem__`` of <HookBeforeAfterGetItem object at ...> 
      on <BeforeAfterGetItemHookedNode object 'hooked' at ...> 
      with args ``('foo',)`` 
      and kw ``{}`` ---
    * after ``__getitem__`` of <HookBeforeAfterGetItem object at ...> 
      on <BeforeAfterGetItemHookedNode object 'hooked' at ...> 
      with args ``('foo',)`` 
      and kw ``{}`` ---
    * before ``__setitem__`` of <HookBeforeAfterSetItem object at ...> 
      on <BeforeAfterGetItemHookedNode object 'foo' at ...> 
      with args ``('bar', <OrderedNode object 'None' at ...>)`` 
      and kw ``{}`` ---
    * after ``__setitem__`` of <HookBeforeAfterSetItem object at ...> 
      on <BeforeAfterGetItemHookedNode object 'foo' at ...> 
      with args ``('bar', <OrderedNode object 'bar' at ...>)`` 
      and kw ``{}`` ---

Remember. The context object on behavior implementation is the behavior 
enhanced node. Test if context access on behavior does not trigger before and 
after handler from within.

Hooked via ``__getattribute__``.
::
    >>> class HookGetAccessFromWithin(BaseBehavior):
    ... 
    ...     @before('get')
    ...     def before_get(self, key, default=None):
    ...         print 'call ``get`` on ' + str(self.context.get(key)) + \
    ...         ' within behavior hook'
    ...         self._debug('before', 'get', key, default=default)
    
    >>> @behavior(HookGetAccessFromWithin)
    ... class AccessedGetFromWithinNode(OrderedNode): pass
    
    >>> node = AccessedGetFromWithinNode('hooked')
    >>> node['foo'] = OrderedNode()
    >>> node.get('foo')
    call ``get`` on <OrderedNode object 'foo' at ...> within behavior hook
    * before ``get`` of <HookGetAccessFromWithin object at ...> 
      on <AccessedGetFromWithinNode object 'hooked' at ...> 
      with args ``('foo',)`` 
      and kw ``{'default': None}`` ---
    <OrderedNode object 'foo' at ...>

Hooked via metaclass constructor.
::
    >>> class HookGetItemAccessFromWithin(BaseBehavior):
    ... 
    ...     @before('__getitem__')
    ...     def before_getitem(self, key):
    ...         print 'call ``__getitem__`` on ' + str(self.context[key]) + \
    ...         ' within behavior hook'
    ...         self._debug('before', '__getitem__', key)
    
    >>> @behavior(HookGetItemAccessFromWithin)
    ... class AccessedGetItemFromWithinNode(OrderedNode): pass
    
    >>> node = AccessedGetItemFromWithinNode('hooked')
    >>> node['foo'] = OrderedNode()
    >>> node['foo']
    call ``__getitem__`` on <OrderedNode object 'foo' at ...> within behavior hook
    * before ``__getitem__`` of <HookGetItemAccessFromWithin object at ...> 
      on <AccessedGetItemFromWithinNode object 'hooked' at ...> 
      with args ``('foo',)`` 
      and kw ``{}`` ---
    <OrderedNode object 'foo' at ...>

Test hook on function derived and overwritten function.
::
    >>> class HookBeforValues(BaseBehavior):
    ...
    ...     @before('values')
    ...     def before_values(self):
    ...         self._debug('before', 'values')
    
    >>> @behavior(HookBeforValues)
    ... class BeforValuesDerivedHookedNode(OrderedNode): pass
    
    >>> node = BeforValuesDerivedHookedNode('hooked')
    >>> node.values()
    * before ``values`` of <HookBeforValues object at ...> 
      on <BeforValuesDerivedHookedNode object 'hooked' at ...> 
      with args ``()`` 
      and kw ``{}`` ---
    []
    
    >>> @behavior(HookBeforValues)
    ... class BeforValuesOverrideHookedNode(OrderedNode):
    ... 
    ...     def values(self):
    ...         return OrderedNode.values(self)
    
    >>> node = BeforValuesOverrideHookedNode('hooked')
    >>> node['foo'] = OrderedNode()
    >>> node.values()
    * before ``values`` of <HookBeforValues object at ...> 
      on <BeforValuesOverrideHookedNode object 'hooked' at ...> 
      with args ``()`` 
      and kw ``{}`` ---
    [<OrderedNode object 'foo' at ...>]

Test hook on property. Fails! Hooks can only be set on functions.
::
    >>> class HookBeforSomeProp(BaseBehavior):
    ... 
    ...     @before('someprop')
    ...     def before_seomprop(self, name, value=None):
    ...         pass
    
    >>> @behavior(HookBeforSomeProp)
    ... class BeforSomepropHookedNode(OrderedNode):
    ... 
    ...     @property
    ...     def someprop(self):
    ...         return 'foo'
    
    >>> node = BeforSomepropHookedNode('hooked')
    >>> node.someprop
    Traceback (most recent call last):
      ...
    AttributeError: someprop

Hooking to behavior proxied function does not work either.
::
    >>> class HookBeforeProxiedDoFunc(BaseBehavior):
    ... 
    ...     def do(self):
    ...         print 'behavior do called'
    ... 
    ...     @before('do')
    ...     def before_do(self):
    ...         self._debug('before', 'do')
    
    >>> @behavior(HookBeforeProxiedDoFunc)
    ... class BeforeProxiedDoFuncHookedNode(OrderedNode): pass 
    
    >>> node = BeforeProxiedDoFuncHookedNode('hooked')
    >>> node.do()
    behavior do called

When providing ``do`` on node as well, the hook will be called. Always check
used behavior interfaces for it's contracts and avoid such magic.
::
    >>> @behavior(HookBeforeProxiedDoFunc)
    ... class BeforeInheritedDoFuncHookedNode(OrderedNode):
    ... 
    ...     def do(self):
    ...         print 'node do called'
    
    >>> node = BeforeInheritedDoFuncHookedNode('hooked')
    >>> node.do()
    * before ``do`` of <HookBeforeProxiedDoFunc object at ...> 
      on <BeforeInheritedDoFuncHookedNode object 'hooked' at ...> 
      with args ``()`` 
      and kw ``{}`` ---
    node do called

Inheriting from a behavior and override hook function.

Does not work without the ``before`` decorator.
::
    >>> class HookOverridingHookIgnored(HookBeforValues):
    ... 
    ...     def before_values(self):
    ...         print 'derived before values'
    
    >>> @behavior(HookOverridingHookIgnored)
    ... class BeforeHookOverridingHookedIgnoredNode(OrderedNode): pass
    
    >>> node = BeforeHookOverridingHookedIgnoredNode('hooked')
    >>> node.values()
    []
    
With decorator.
::
    
    >>> class HookOverridingHook(HookBeforValues):
    ... 
    ...     @before('values')
    ...     def before_values(self):
    ...         print 'derived before values'
    
    >>> @behavior(HookOverridingHook)
    ... class BeforeHookOverridingHookedNode(OrderedNode): pass
    
    >>> node = BeforeHookOverridingHookedNode('hooked')
    >>> node.values()
    derived before values
    []

Check ``noderepr``.
::
    >>> node.noderepr
    "<class 'BeforeHookOverridingHookedNode'>: hooked"


Run Testers against wrapper
---------------------------

FullMappingTester.
::
    >>> @behavior(OtherBehavior, SomeBehavior)
    ... class BehaviorNode(OrderedNode):
    ... 
    ...     def do(self):
    ...         return 'do on node ' + str(self)
    
    >>> from node.testing import FullMappingTester
    >>> tester = FullMappingTester(BehaviorNode)
    >>> tester.run()
    >>> tester.combined
    ``__setitem__``: OK
    ``__getitem__``: OK
    ``get``: OK
    ``__iter__``: OK
    ``keys``: OK
    ``iterkeys``: OK
    ``values``: OK
    ``itervalues``: OK
    ``items``: OK
    ``iteritems``: OK
    ``__contains__``: OK
    ``has_key``: OK
    ``__len__``: OK
    ``update``: OK
    ``__delitem__``: OK
    ``copy``: OK
    ``setdefault``: OK
    ``pop``: OK
    ``popitem``: OK
    ``clear``: OK
