node.base
=========

Helper function for creating identically tree structures from different classes.
::

    >>> def create_tree(class_):
    ...     root = class_()
    ...     for i in range(3):
    ...         root['child-%i' % i] = class_()
    ...         for j in range(2):
    ...             root['child-%i' % i]['subchild-%i' % j] = class_()
    ...     return root


AbstractNode
------------
::

    >>> from node.base import AbstractNode
    >>> AbstractNode
    <class 'node.base.AbstractNode'>
    
    >>> AbstractNode.__bases__
    (<class 'node.base._NodeMixin'>, <class 'node.base._FullMappingMixin'>)
    
    >>> abstract = AbstractNode()
    >>> abstract
    <AbstractNode object 'None' at ...>

Storage related operations of AbstractNode raise ``NotImplementedError``.
::

    >>> abstract['foo']
    Traceback (most recent call last):
      ...
    NotImplementedError
    
    >>> del abstract['foo']
    Traceback (most recent call last):
      ...
    NotImplementedError
    
    >>> abstract['foo'] = 'bar'
    Traceback (most recent call last):
      ...
    NotImplementedError
    
    >>> [key for key in abstract]
    Traceback (most recent call last):
      ...
    NotImplementedError
    
    >>> abstract_copy = abstract.copy()
    Traceback (most recent call last):
      ...
    NotImplementedError
    
    >>> abstract.clear()
    Traceback (most recent call last):
      ...
    NotImplementedError
    
    >>> abstract.update((('foo', 'bar'),))
    Traceback (most recent call last):
      ...
    NotImplementedError
    
    >>> abstract.setdefault('foo', 'bar')
    Traceback (most recent call last):
      ...
    NotImplementedError
    
    >>> abstract.pop('foo')
    Traceback (most recent call last):
      ...
    NotImplementedError
    
    >>> abstract.popitem()
    Traceback (most recent call last):
      ...
    NotImplementedError
    
Subclass ``AbstractNode`` and provide needed functions.

Below we utilize ``odict.odict`` for most of the work. There exists node 
``OrderedNode``, which already uses odict, so for illustration we import odict
as somefullmapping.
::

    >>> from odict import odict as somefullmapping
    >>> class MyNode(AbstractNode, somefullmapping):
    ...     def __init__(self, name=None, parent=None):
    ...         # XXX: using ``super`` on dedicated base class? how?
    ...         somefullmapping.__init__(self)
    ...         AbstractNode.__init__(self, name, parent)
    ... 
    ...     __getitem__ = somefullmapping.__getitem__
    ... 
    ...     __delitem__ = somefullmapping.__delitem__
    ... 
    ...     def __setitem__(self, key, val):
    ...         val.__name__ = key
    ...         val.__parent__ = self
    ...         somefullmapping.__setitem__(self, key, val)
    ... 
    ...     __iter__ = somefullmapping.__iter__
    ... 
    ...     copy = somefullmapping.copy
    ... 
    ...     clear = somefullmapping.clear
    ... 
    ...     update = somefullmapping.update
    ... 
    ...     setdefault = somefullmapping.setdefault
    ... 
    ...     pop = somefullmapping.pop
    ... 
    ...     popitem = somefullmapping.popitem
    
    >>> mynode = MyNode()
    >>> mynode
    <MyNode object 'None' at ...>
    
    ### later
    
    >>> mynode = create_tree(MyNode)
    >>> mynode
    <MyNode object 'None' at ...>
    
    >>> mynode.printtree()
    <class 'MyNode'>: None
      <class 'MyNode'>: child-0
        <class 'MyNode'>: subchild-0
        <class 'MyNode'>: subchild-1
      <class 'MyNode'>: child-1
        <class 'MyNode'>: subchild-0
        <class 'MyNode'>: subchild-1
      <class 'MyNode'>: child-2
        <class 'MyNode'>: subchild-0
        <class 'MyNode'>: subchild-1

    ### / later

BaseNode
--------
::

    >>> from node.base import BaseNode
    >>> BaseNode
    <class 'node.base.BaseNode'>
    
    >>> BaseNode.__bases__
    (<class 'node.base._NodeSpaceMixin'>, <type 'dict'>)
    
    >>> basenode = BaseNode()
    >>> basenode
    <BaseNode object 'None' at ...>
    
    ### later
    
    >>> basenode = create_tree(BaseNode)
    >>> basenode
    <BaseNode object 'None' at ...>
    
    >>> basenode.printtree()
    <class 'node.base.BaseNode'>: None
      <class 'node.base.BaseNode'>: child-...
        <class 'node.base.BaseNode'>: subchild-...
        <class 'node.base.BaseNode'>: subchild-...
      <class 'node.base.BaseNode'>: child-...
        <class 'node.base.BaseNode'>: subchild-...
        <class 'node.base.BaseNode'>: subchild-...
      <class 'node.base.BaseNode'>: child-...
        <class 'node.base.BaseNode'>: subchild-...
        <class 'node.base.BaseNode'>: subchild-...

    ### / later

OrderedNode
-----------
::

    >>> from node.base import OrderedNode
    >>> OrderedNode
    <class 'node.base.OrderedNode'>
    
    >>> OrderedNode.__bases__
    (<class 'node.base._NodeSpaceMixin'>, <class 'odict.pyodict.odict'>)
    
    >>> orderednode = OrderedNode()
    >>> orderednode
    <OrderedNode object 'None' at ...>
    
    ### later
    
    >>> orderednode = create_tree(OrderedNode)
    >>> orderednode
    <OrderedNode object 'None' at ...>
    
    >>> orderednode.printtree()
    <class 'node.base.OrderedNode'>: None
      <class 'node.base.OrderedNode'>: child-0
        <class 'node.base.OrderedNode'>: subchild-0
        <class 'node.base.OrderedNode'>: subchild-1
      <class 'node.base.OrderedNode'>: child-1
        <class 'node.base.OrderedNode'>: subchild-0
        <class 'node.base.OrderedNode'>: subchild-1
      <class 'node.base.OrderedNode'>: child-2
        <class 'node.base.OrderedNode'>: subchild-0
        <class 'node.base.OrderedNode'>: subchild-1

    ### / later


IFullMapping contract
---------------------
::
    
    - derived from ``IItemMapping``
        - ``__getitem__``
    
    - derived from ``IReadMapping``
        - ``get``
        - ``__contains__``

    - derived from ``IWriteMapping``
        - ``__delitem__``
        - ``__setitem__``

    - derived from ``IEnumerableMapping``
        - ``keys``
        - ``__iter__``
        - ``values``
        - ``items``
        - ``__len__``
    
    - derived from ``IIterableMapping``
        - ``iterkeys``
        - ``itervalues``
        - ``iteritems``

    - derived from ``IClonableMapping``
        - ``copy``

    - derived from ``IExtendedReadMapping``
        - ``has_key``

    - derived from ``IExtendedWriteMapping``
        - ``clear``
        - ``update``
        - ``setdefault``
        - ``pop``
        - ``popitem``

ILocation contract
------------------
::

INode contract
--------------
::